# 2025年1月6日 JVM知识点问答学习记录

## 学习主题：JVM核心知识点深度问答

### 知识点1：什么是JVM？它在Java程序运行中扮演什么角色？

**对话：**

老师：什么是JVM？它在Java程序运行中扮演什么角色？

用户：JVM指java虚拟机，它是 Java 实现跨平台的基⽯。程序运⾏之前，需要先通过编译器将 Java 源代码⽂件编译成 Java 字节码⽂件；程序运⾏时，JVM 会对字节码⽂件进⾏逐⾏解释，翻译成机器码指令，并交给对应的操作系统去执⾏。这样可以实现一次编译处处运行的优点。此外，jvm还有自动管理内存，拥有jit即时编译的优点。

老师：你说JVM对字节码进行"逐行解释"，但你也提到了JIT即时编译。这两种执行方式有什么区别？JVM是如何在解释执行和编译执行之间做选择的？

用户：解释执行将字节码逐条翻译成机器码并立即执行。而JIT 即时编译将整个方法或代码块编译成本地机器码，并缓存起来。现代 JVM采用的是解释器与编译器并存的架构。JVM 会将热点代码（即运⾏频率⾼的代码）编译后放⼊ CodeCache，当下次执⾏再遇到这段代码时，会从 CodeCache 中直接读取机器码，然后执⾏。

老师：你提到了"热点代码"会被JIT编译。JVM是如何判断哪些代码是热点代码的？有没有具体的阈值或者检测机制？

用户：可以通过计时的方法，这点我不是很清楚了。就到这里吧。

---

### 知识点2：JVM的内存区域主要分为哪几部分？哪些是线程共享的，哪些是线程私有的？

**对话：**

老师：JVM的内存区域主要分为哪几部分？哪些是线程共享的，哪些是线程私有的？

用户：JVM的内存区域包括程序计数器、虚拟机栈、本地方法栈、堆、方法区。堆和方法区是线程共享的，其他三个是线程私有的。线程私有的是为了线程安全，共享的是为了数据共享。

老师：程序计数器记录当前线程执行的位置，虚拟机栈存储方法调用信息，本地方法栈处理native方法，堆存放对象实例，方法区存放类信息、常量等。

---

### 知识点3：为什么JDK 1.8要用元空间替代永久代？元空间有什么优势？

**对话：**

老师：为什么JDK 1.8要用元空间替代永久代？元空间有什么优势？

用户：永久代容易内存溢出，受JVM内存限制，元空间使用本地内存。元空间不会出现永久代OOM，动态调整大小，垃圾回收更高效。

老师：元空间在什么情况下会内存溢出？

用户：本地内存不足时，或者类加载太多。

---

### 知识点4：当你使用new关键字创建一个对象时，JVM内部经历了哪些步骤？

**对话：**

老师：当你使用new关键字创建一个对象时，JVM内部经历了哪些步骤？

用户：先检查类是否加载，然后分配内存，初始化对象，设置对象头。对象头包含类信息、哈希码、GC分代年龄等。对象初始化时成员变量默认值：数值类型是0，布尔是false，对象是null。

老师：对象头具体包含什么信息？

用户：Mark Word和类型指针。

---

### 知识点5：堆内存分配有哪两种主要策略？它们分别适用于什么场景？

**对话：**

老师：堆内存分配有哪两种主要策略？它们分别适用于什么场景？

用户：指针碰撞和空闲列表。指针碰撞适合年轻代，内存规整；空闲列表适合老年代，内存碎片化。年轻代用指针碰撞是因为年轻代对象生命周期短，内存回收后比较规整。

老师：为什么老年代更适合用空闲列表？

用户：老年代对象存活时间长，内存碎片化严重，空闲列表可以更好地管理不连续的内存空间。

---

### 知识点6：多线程环境下new对象会发生什么竞争问题？JVM如何解决这个问题？

**对话：**

老师：多线程环境下new对象会发生什么竞争问题？JVM如何解决这个问题？

用户：会发生内存分配竞争。JVM使用TLAB，线程本地分配缓存。每个线程预先分配一小块内存，在自己的TLAB里分配对象，避免竞争。

老师：TLAB的大小是如何确定的？

用户：可以通过JVM参数调整，默认情况下JVM会根据线程数量和堆大小自动调整。

---

### 知识点7：对象在内存中的布局是怎样的？对象头包含哪些重要信息？

**对话：**

老师：对象在内存中的布局是怎样的？对象头包含哪些重要信息？

用户：对象头、实例数据、对齐填充。对象头包含Mark Word和类型指针。对齐填充的作用是让对象大小是8字节的倍数，提高访问效率。

老师：Mark Word具体存储什么信息？

用户：存储对象的哈希码、GC分代年龄、锁状态标志等运行时数据。

---

### 知识点8：JVM访问对象有哪两种方式？HotSpot虚拟机采用哪种方式？为什么？

**对话：**

老师：JVM访问对象有哪两种方式？HotSpot虚拟机采用哪种方式？为什么？

用户：句柄和直接指针。HotSpot用直接指针。直接指针访问速度快，少一次指针定位。

老师：句柄方式有什么优势？

用户：对象被移动时只需要修改句柄表中的指针，而不需要修改对象引用本身。

---

### 知识点9：Java中有哪几种引用类型？它们的主要区别是什么？

**对话：**

老师：Java中有哪几种引用类型？它们的主要区别是什么？

用户：强引用、软引用、弱引用、虚引用。强引用只要存在，对象就不会被回收。软引用在内存不足时回收，弱引用在下一次GC时回收。

老师：虚引用有什么特殊用途？

用户：虚引用主要用于跟踪对象被垃圾回收的状态，必须和引用队列联合使用。

---

### 知识点10：Java堆是如何分区的？新生代和老年代各有什么特点？

**对话：**

老师：Java堆是如何分区的？新生代和老年代各有什么特点？

用户：新生代和老年代。新对象在Eden区，经过多次GC后存活的对象进入老年代。新生代对象生命周期短，回收频繁；老年代对象生命周期长，回收较少。

老师：新生代为什么采用标记-复制算法？

用户：新生代对象存活率低，复制存活对象效率高。

---

### 知识点11：新生代为什么要划分为Eden区和Survivor区？它们的比例是多少？

**对话：**

老师：新生代为什么要划分为Eden区和Survivor区？它们的比例是多少？

用户：为了使用标记-复制算法。Eden和Survivor的比例是8:1:1。

老师：为什么用标记-复制算法？

用户：新生代对象存活率低，每次复制少量的存活对象效率比较高。

---

### 知识点12：对象什么时候会从新生代晋升到老年代？有哪些触发条件？

**对话：**

老师：对象什么时候会从新生代晋升到老年代？有哪些触发条件？

用户：年龄计数器达到阈值，或者大对象直接进入。每次Minor GC存活，年龄加1，达到15进入老年代。大对象直接进老年代是为了避免在新生代频繁复制。

老师：年龄计数器阈值可以调整吗？

用户：可以通过-XX:MaxTenuringThreshold参数调整。

---

### 知识点13：什么是STW（Stop The World）？为什么垃圾回收需要STW？

**对话：**

老师：什么是STW（Stop The World）？为什么垃圾回收需要STW？

用户：Stop The World，垃圾回收时暂停所有用户线程。需要STW是为了保证对象移动时引用关系不变。通过安全点机制实现安全暂停。

老师：安全点是如何工作的？

用户：JVM会在特定位置设置安全点，线程执行到安全点时会检查是否需要暂停。

---

### 知识点14：对象一定在堆上分配吗？什么情况下对象可以在栈上分配？

**对话：**

老师：对象一定在堆上分配吗？什么情况下对象可以在栈上分配？

用户：不一定，JVM会做逃逸分析。对象生命周期只在方法内部，没有逃逸时可以在栈上分配。栈上分配的好处是方法结束时自动回收，减少GC压力。

老师：逃逸分析的具体条件是什么？

用户：对象不会被方法外部引用，不会作为返回值，不会赋值给类变量或实例变量。

---

### 知识点15：内存溢出和内存泄漏有什么区别？各有什么典型表现？

**对话：**

老师：内存溢出和内存泄漏有什么区别？各有什么典型表现？

用户：溢出是内存不足，泄漏是对象无法回收。溢出表现为OutOfMemoryError，泄漏表现为内存使用持续增长。

老师：什么情况会导致内存溢出？

用户：创建大量对象，或者内存配置不合理。

---

### 知识点16：你能写一个会导致堆内存溢出的代码示例吗？如何避免这种情况？

**对话：**

老师：你能写一个会导致堆内存溢出的代码示例吗？如何避免这种情况？

用户：
```java
List<byte[]> list = new ArrayList<>();
while(true) {
    list.add(new byte[10 * 1024 * 1024]);
}
```
无限创建10MB数组，很快堆内存耗尽。避免方法是合理使用内存，及时释放不再使用的对象。

老师：除了代码优化，还有什么方法可以避免内存溢出？

用户：合理配置JVM参数，增加堆内存大小。

---

### 知识点17：常见的内存泄漏场景有哪些？如何排查内存泄漏问题？

**对话：**

老师：常见的内存泄漏场景有哪些？如何排查内存泄漏问题？

用户：静态集合、ThreadLocal未清理、连接未关闭。先用jstat看内存变化，再用jmap导出堆文件，用MAT分析。MAT能看到对象引用链，找到泄漏的根源。

老师：ThreadLocal怎么正确使用？

用户：用完后调用remove方法清理。

---

### 知识点18：什么情况下会发生栈溢出？递归调用为什么会容易导致栈溢出？

**对话：**

老师：什么情况下会发生栈溢出？递归调用为什么会容易导致栈溢出？

用户：方法调用嵌套太深，栈空间不足。递归调用没有终止条件会导致递归无限进行。控制递归深度，使用迭代替代递归，增加栈大小可以避免栈溢出。

老师：栈大小可以通过什么参数调整？

用户：-Xss参数调整栈大小。

---

### 知识点19：如何判断一个对象是否可以被垃圾回收？GC Roots包括哪些对象？

**对话：**

老师：如何判断一个对象是否可以被垃圾回收？GC Roots包括哪些对象？

用户：通过可达性分析，从GC Roots开始遍历，无法到达的对象可以被回收。GC Roots包括虚拟机栈中引用的对象、方法区中类静态属性引用的对象、方法区中常量引用的对象等。

老师：本地方法栈中引用的对象也是GC Roots吗？

用户：是的，本地方法栈中引用的对象也是GC Roots。

---

### 知识点20：垃圾收集算法主要有哪些？标记-复制算法为什么适合新生代？

**对话：**

老师：垃圾收集算法主要有哪些？标记-复制算法为什么适合新生代？

用户：标记清除、复制、标记整理、分代收集。标记-复制算法适合新生代是因为新生代对象存活率低，复制存活对象效率高。

老师：标记-清除算法有什么缺点？

用户：会产生内存碎片，需要额外的整理操作。

---

**今日总结：**
今天我们通过20个深度问答系统学习了JVM的核心知识点，从基础概念到实际应用，从内存管理到垃圾回收机制。通过问答形式加深了对JVM工作原理的理解，为后续的深入学习打下了坚实基础。
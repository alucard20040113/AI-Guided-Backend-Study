# 2025年1月20日 Java核心技术综合学习记录

## 学习主题：Java集合、并发、JVM、MySQL四大板块深度掌握

### 第一板块：Java 集合框架 (Collections)

#### 知识点1：Java的常见集合介绍下（体系概览）

**对话：**

老师：Java的常见集合介绍下，从体系概览的角度。

用户：Java集合框架分为Collection和Map两大接口。Collection包括List、Set、Queue，Map包括HashMap、TreeMap等。List有序可重复，Set无序不重复，Map键值对存储。

老师：ArrayList和LinkedList的区别是什么？

用户：ArrayList基于数组，随机访问快，插入删除慢；LinkedList基于链表，插入删除快，随机访问慢。

---

#### 知识点2：哪些集合是线程安全的，哪些是不安全的（安全性区分）

**对话：**

老师：哪些集合是线程安全的，哪些是不安全的？

用户：线程安全的有Vector、Hashtable、ConcurrentHashMap、CopyOnWriteArrayList等；不安全的有ArrayList、HashMap、HashSet等。

老师：为什么HashMap不是线程安全的？

用户：多线程环境下，HashMap在扩容时可能形成环形链表，导致死循环或数据丢失。

---

#### 知识点3：HashMap与ConcurrentHashMap的区别（核心对比）

**对话：**

老师：HashMap与ConcurrentHashMap的区别是什么？

用户：HashMap非线程安全，ConcurrentHashMap线程安全；HashMap允许null键值，ConcurrentHashMap不允许；ConcurrentHashMap使用分段锁或CAS保证并发安全。

老师：ConcurrentHashMap如何实现高并发？

用户：JDK1.7使用分段锁，JDK1.8使用CAS+synchronized，锁粒度更细，并发性能更好。

---

#### 知识点4：ConcurrentHashMap在JDK 1.7和JDK 1.8中的实现有什么区别？（源码演进）

**对话：**

老师：ConcurrentHashMap在JDK 1.7和JDK 1.8中的实现有什么区别？

用户：JDK1.7使用Segment分段锁，每个Segment独立加锁；JDK1.8使用Node数组+CAS+synchronized，锁粒度更细，性能更好。

老师：为什么JDK1.8要改变实现方式？

用户：减少锁竞争，提高并发性能，同时简化了实现逻辑。

---

#### 知识点5：ConcurrentHashMap是如何保证读操作（get）不需要加锁的？（底层原理）

**对话：**

老师：ConcurrentHashMap是如何保证读操作（get）不需要加锁的？

用户：通过volatile修饰的Node数组和链表节点，保证内存可见性；同时使用Unsafe类进行原子操作，确保读操作的安全性。

老师：volatile关键字在这里的作用是什么？

用户：保证多线程环境下对共享变量的可见性，防止读取到过期的数据。

---

#### 知识点6：ConcurrentHashMap的线程安全怎么实现的（CAS + Synchronized 机制）

**对话：**

老师：ConcurrentHashMap的线程安全怎么实现的？

用户：JDK1.8使用CAS+synchronized机制。插入时先CAS尝试，失败则synchronized加锁；扩容时使用ForwardingNode和sizeCtl控制。

老师：CAS操作有什么优缺点？

用户：优点是无锁，性能高；缺点是可能产生ABA问题，需要配合版本号解决。

---

### 第二板块：Java 并发编程 (Concurrency)

#### 知识点7：Java的锁机制介绍一下（悲观锁、乐观锁、AQS）

**对话：**

老师：Java的锁机制介绍一下，包括悲观锁、乐观锁、AQS。

用户：悲观锁如synchronized，认为并发冲突概率高；乐观锁如CAS，认为并发冲突概率低；AQS是构建锁的框架，如ReentrantLock。

老师：synchronized和ReentrantLock的区别？

用户：synchronized是关键字，自动释放锁；ReentrantLock是类，需要手动释放，支持公平锁和条件变量。

---

#### 知识点8：能否帮我组织语言（关于锁机制的面试话术）

**对话：**

老师：关于锁机制，面试时应该怎么组织语言？

用户：先介绍锁的分类，然后对比synchronized和ReentrantLock，最后结合实际场景说明选择依据。

老师：具体说说选择依据？

用户：简单场景用synchronized，复杂场景用ReentrantLock；需要公平锁或条件变量时用ReentrantLock。

---

#### 知识点9：ReentrantLock实现原理介绍一下（AQS、State、队列）

**对话：**

老师：ReentrantLock实现原理介绍一下。

用户：基于AQS框架，通过state状态表示锁的持有次数，使用CLH队列管理等待线程，支持公平和非公平两种模式。

老师：AQS的核心思想是什么？

用户：通过一个int类型的state表示同步状态，使用FIFO队列管理等待线程，提供模板方法供子类实现。

---

#### 知识点10：volatile关键字介绍下（可见性、有序性）

**对话：**

老师：volatile关键字介绍下。

用户：volatile保证可见性和有序性。可见性：修改立即对其他线程可见；有序性：防止指令重排序。

老师：volatile能保证原子性吗？

用户：不能，volatile只能保证单次读写的原子性，不能保证复合操作的原子性。

---

#### 知识点11：内存屏障怎么理解（底层指令、JMM）

**对话：**

老师：内存屏障怎么理解？

用户：内存屏障是CPU指令，用于控制指令执行顺序。包括读屏障、写屏障、全屏障，保证多线程环境下的内存可见性。

老师：在JMM中内存屏障的作用？

用户：保证happens-before关系，防止编译器和处理器对指令进行重排序。

---

#### 知识点12：Java创建线程池怎么实现（ThreadPoolExecutor 7大参数）

**对话：**

老师：Java创建线程池怎么实现？

用户：使用ThreadPoolExecutor，7大参数：核心线程数、最大线程数、空闲时间、时间单位、工作队列、线程工厂、拒绝策略。

老师：核心线程数和最大线程数如何设置？

用户：根据任务类型：CPU密集型设置核心数+1，IO密集型设置2*核心数。

---

#### 知识点13：拒绝策略都有什么（4种内置策略及应用场景）

**对话：**

老师：拒绝策略都有什么？

用户：4种内置策略：AbortPolicy抛出异常，CallerRunsPolicy调用者执行，DiscardPolicy直接丢弃，DiscardOldestPolicy丢弃最老任务。

老师：各策略适用场景？

用户：AbortPolicy用于重要任务，CallerRunsPolicy用于可降级任务，DiscardPolicy用于不重要任务。

---

### 第三板块：JVM (虚拟机)

#### 知识点14：JVM调参怎么实现（调优步骤、参数设置）

**对话：**

老师：JVM调参怎么实现？

用户：先监控分析，确定瓶颈；然后设置堆大小、新生代老年代比例、垃圾收集器等参数；最后验证优化效果。

老师：常用的JVM参数有哪些？

用户：-Xms初始堆大小，-Xmx最大堆大小，-Xmn新生代大小，-XX:+UseG1GC使用G1收集器等。

---

#### 知识点15：什么是GC（垃圾回收概念、算法）

**对话：**

老师：什么是GC？

用户：GC是垃圾回收，自动管理内存。主要算法：标记-清除、标记-整理、复制算法。分代收集理论：新生代用复制算法，老年代用标记-整理。

老师：为什么分代收集？

用户：根据对象生命周期特点，新生代对象朝生夕死，老年代对象存活时间长，不同代使用不同算法提高效率。

---

#### 知识点16：知道有哪些常见的垃圾收集器吗？（分代收集器体系）

**对话：**

老师：知道有哪些常见的垃圾收集器吗？

用户：Serial/Serial Old，Parallel Scavenge/Parallel Old，ParNew/CMS，G1，ZGC，Shenandoah。

老师：CMS收集器的特点？

用户：并发标记清除，低停顿时间，但会产生内存碎片，需要Full GC时进行碎片整理。

---

#### 知识点17：G1相比CMS有什么优势？为什么现在推荐用G1？（设计理念对比）

**对话：**

老师：G1相比CMS有什么优势？为什么现在推荐用G1？

用户：G1可预测停顿时间，分区回收减少碎片，整体性能更好。CMS在JDK9已标记废弃，G1是官方推荐。

老师：G1如何实现可预测停顿？

用户：通过Region分区，每次回收价值最高的Region，控制回收时间在预期范围内。

---

#### 知识点18：JVM怎么分析线上进程线程对象的信息？（排查工具 jstack, jmap, Arthas）

**对话：**

老师：JVM怎么分析线上进程线程对象的信息？

用户：使用jstack分析线程状态，jmap分析内存分布，jstat监控GC情况，Arthas进行在线诊断。

老师：jstack能发现什么问题？

用户：死锁、线程阻塞、CPU占用高等问题，通过线程堆栈信息定位具体代码位置。

---

### 第四板块：MySQL (数据库)

#### 知识点19：MySQL的底层索引的数据结构是什么（B+ 树原理）

**对话：**

老师：MySQL的底层索引的数据结构是什么？

用户：InnoDB使用B+树索引。B+树是多路平衡查找树，所有数据存储在叶子节点，非叶子节点只存索引，叶子节点间有指针连接。

老师：B+树相比B树的优势？

用户：查询效率稳定，所有查询都要到叶子节点；范围查询效率高，叶子节点有序连接；更适合磁盘IO，节点大小通常为页的整数倍。

---

#### 知识点20：聚簇索引 vs 非聚簇索引（回表、叶子节点存储内容）

**对话：**

老师：聚簇索引 vs 非聚簇索引的区别？

用户：聚簇索引叶子节点存储整行数据，表数据即索引数据；非聚簇索引叶子节点存储主键值，需要回表查询。

老师：什么是回表查询？

用户：非聚簇索引找到主键后，需要再到聚簇索引中查找完整数据，这个过程称为回表。

---

#### 知识点21：你都知道哪些索引（索引分类）

**对话：**

老师：你都知道哪些索引？

用户：主键索引、唯一索引、普通索引、联合索引、全文索引、空间索引等。

老师：联合索引的建立原则？

用户：最左前缀原则，区分度高的列在前，经常用于查询和排序的列优先。

---

#### 知识点22：怎么分析建立的索引是否生效（Explain 执行计划详解）

**对话：**

老师：怎么分析建立的索引是否生效？

用户：使用Explain查看执行计划，关注type、key、rows、Extra等字段。type为ref或range表示索引生效。

老师：Explain中的type字段有哪些值？

用户：const、eq_ref、ref、range、index、all，性能从好到差。

---

#### 知识点23：什么是索引失效（7大失效场景）

**对话：**

老师：什么是索引失效？常见的失效场景有哪些？

用户：7大失效场景：like以通配符开头，对索引列进行运算，使用or条件，类型转换，使用not in，联合索引不满足最左前缀，数据量少时优化器选择全表扫描。

老师：如何避免索引失效？

用户：避免在索引列上运算，like查询避免前导通配符，联合索引注意最左前缀原则。

---

#### 知识点24：说说联合索引（排序规则、覆盖索引）

**对话：**

老师：说说联合索引的特点？

用户：联合索引遵循最左前缀原则，可以用于排序和分组，如果查询字段都在索引中则形成覆盖索引避免回表。

老师：什么是覆盖索引？

用户：查询的字段都包含在索引中，不需要回表查询，性能最好。

---

#### 知识点25：联合索引建立之后，使用了两个字段做过滤，那么有没有可能不走索引（坑题：OR、区分度低、隐式转换等）

**对话：**

老师：联合索引建立后，使用两个字段过滤，有没有可能不走索引？

用户：有可能，如果使用OR连接条件，或者其中一个条件导致类型转换，或者数据区分度太低，优化器可能选择全表扫描。

老师：如何判断是否走了索引？

用户：使用Explain查看执行计划，观察key字段是否使用了索引。

---

#### 知识点26：MySQL怎么分库分页？什么情况下分库？什么情况下分页？（架构设计）

**对话：**

老师：MySQL怎么分库分页？什么情况下需要分库？什么情况下需要分页？

用户：分库解决单库性能瓶颈，分页解决大数据量查询问题。分库：数据量大、并发高；分页：数据展示需要分段。

老师：分库分页的挑战？

用户：跨库查询复杂，分页效率低，数据一致性难保证。

---

#### 知识点27：如果让你几句话说完分库后怎么做分页？你怎么说（最大 ID 法、ES 降维）

**对话：**

老师：分库后怎么做分页？用几句话说明。

用户：使用最大ID法，记录上次查询的最大ID，下次查询从该ID开始；或者使用ES等中间件进行数据聚合和分页。

老师：最大ID法的优缺点？

用户：优点简单高效，缺点不支持跳页，只能顺序翻页。

---

#### 知识点28：说说三大范式（数据库设计理论）

**对话：**

老师：说说数据库设计的三大范式。

用户：第一范式：属性原子性；第二范式：消除部分依赖；第三范式：消除传递依赖。

老师：范式的目的是什么？

用户：减少数据冗余，提高数据一致性，但过度范式化可能影响查询性能。

---

#### 知识点29：第二范式 举个例子（消除部分依赖实战）

**对话：**

老师：第二范式举个例子说明。

用户：学生选课表（学号，课程号，成绩，课程名称）。课程名称依赖于课程号，而不完全依赖于主键（学号，课程号），违反第二范式。

老师：如何解决？

用户：拆分为学生选课表（学号，课程号，成绩）和课程表（课程号，课程名称），消除部分依赖。

---

## 学习总结

今天系统学习了Java集合框架、并发编程、JVM和MySQL四个核心技术板块的29个知识点。通过Socratic对话形式，深入理解了每个技术概念的核心要点和实际应用场景。这些知识点涵盖了面试中常见的技术问题，为技术面试做好了充分准备。
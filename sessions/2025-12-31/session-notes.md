# 2025年12月31日 Java基础学习记录

## 学习主题：Java高级特性与框架基础

### 知识点65：Java注解（Annotation）

**对话：**

用户：什么是Java注解？它有什么作用？

老师：注解本质上是Java代码中的标记，你可以把它想象成给人戴的帽子或眼镜这样的装饰品。注解可以标记在类上、方法上、属性上等。你觉得这种标记有什么用呢？

用户：标记之后应该可以在编译或者运行时被识别，然后做一些处理？

老师：对的！注解的用途就是在编译或运行阶段识别这些标记，然后执行相应的操作。比如常见的@Override注解，你知道它的作用是什么吗？

用户：应该是用来标记方法重写的吧？

老师：是的！@Override就是给编译器用的，编译器在编译时会检查这个方法是否真的重写了父类的方法。如果检查没问题，class文件里就不会保留这个标记。那你能想到注解的生命周期有哪些吗？

用户：应该有编译时、运行时之类的？

老师：是的！注解的生命周期有三大类：
- RetentionPolicy.SOURCE：给编译器用的，不会写入class文件
- RetentionPolicy.CLASS：会写入class文件，但在类加载阶段丢弃
- RetentionPolicy.RUNTIME：会写入class文件，永久保存，可以通过反射获取

你能举出一些RUNTIME级别注解的例子吗？

用户：Spring的@Autowired应该是RUNTIME的吧？

老师：完全正确！@Autowired就是RUNTIME级别的，所以在运行时可以通过反射得到注解的信息，还能拿到标记的值required。注解在框架开发中非常重要，你想想还有什么场景会用到注解？

用户：Lombok应该也用了注解吧？

老师：对！Lombok就是注解在编译期运行的典型例子。它通过注解在编译时自动生成代码，比如@Data注解会自动生成getter、setter、toString等方法。注解让我们的代码更加简洁和声明式。

---

### 知识点66：Java动态代理（Dynamic Proxy）

**对话：**

用户：什么是动态代理？它和静态代理有什么区别？

老师：动态代理是在运行时动态创建代理类，而静态代理需要在编译时就定义好代理类。你能想到动态代理有什么优势吗？

用户：动态代理应该更灵活，不需要为每个目标类都写一个代理类？

老师：是的！动态代理可以在运行时动态处理方法调用，这在实现AOP和拦截器时非常有用。Java中动态代理的实现方式有哪些？

用户：好像有JDK动态代理和CGLIB？

老师：对的！JDK动态代理基于接口，使用反射机制；CGLIB基于继承，通过字节码技术生成子类。你能说说它们的区别吗？

用户：JDK动态代理只能代理接口，CGLIB可以代理类？

老师：是的！JDK动态代理要求目标类实现接口，而CGLIB通过继承目标类来创建代理，所以不能代理final类。你知道动态代理的应用场景有哪些吗？

用户：AOP应该算一个吧？

老师：对！AOP（面向切面编程）就是动态代理的典型应用场景，比如日志记录、事务管理、权限验证等。还有RPC框架、事务管理等都用到了动态代理。动态代理的核心是什么？

用户：应该是拦截方法调用，在方法前后做一些处理？

老师：是的！动态代理的核心就是在目标方法执行前后插入自定义逻辑。比如我们可以在方法调用前记录日志，调用后统计执行时间。这大大提高了代码的可维护性和复用性。

---

### 知识点67：设计模式-单例模式

**对话：**

用户：什么是单例模式？为什么要用单例模式？

老师：单例模式确保一个类只有一个实例，并提供一个全局访问点。你能想到哪些场景适合用单例模式吗？

用户：配置管理器、数据库连接池、日志管理器？

老师：很好！这些场景确实适合单例模式。单例模式的核心要素是什么？

用户：私有构造方法、静态实例、静态获取方法？

老师：对的！单例模式的关键是：私有构造方法防止外部实例化、静态私有实例变量、公共静态访问方法。你知道单例模式有哪些实现方式吗？

用户：饿汉式、懒汉式、双重检查锁？

老师：是的！饿汉式在类加载时就创建实例，线程安全但可能浪费资源；懒汉式在首次使用时创建，需要考虑线程安全问题。双重检查锁有什么优点？

用户：既延迟加载又保证线程安全？

老师：对的！双重检查锁既实现了懒加载，又通过synchronized保证了线程安全，而且只在第一次创建时加锁，性能较好。还有没有其他实现方式？

用户：静态内部类？

老师：对！静态内部类利用了类加载机制，既实现了懒加载，又保证了线程安全，是推荐的方式之一。你想想单例模式有什么缺点？

用户：可能不利于扩展和测试？

老师：是的！单例模式违反单一职责原则，扩展困难，而且不利于单元测试。在分布式环境下，单例模式可能失效，需要特别注意。

---

### 知识点68：设计模式-工厂模式

**对话：**

用户：什么是工厂模式？它解决了什么问题？

老师：工厂模式将对象的创建和使用分离，通过工厂类来创建对象。你能想到这样做的好处吗？

用户：降低耦合，方便扩展？

老师：对的！工厂模式的主要优点是解耦、扩展性好、符合开闭原则。工厂模式有哪些类型？

用户：简单工厂、工厂方法、抽象工厂？

老师：是的！简单工厂有一个工厂类根据参数创建不同对象；工厂方法为每个产品创建一个工厂；抽象工厂创建产品族。你能举个例子说明简单工厂吗？

用户：比如创建不同类型的日志记录器？

老师：对！比如我们可以创建一个LoggerFactory，根据配置创建FileLogger、ConsoleLogger等。简单工厂有什么缺点？

用户：新增产品时需要修改工厂类？

老师：是的！简单工厂违反开闭原则，新增产品需要修改工厂类。工厂方法模式怎么解决这个问题？

用户：为每个产品创建一个工厂类？

老师：对的！工厂方法模式为每个产品定义一个工厂接口和实现，新增产品时只需新增工厂类，不需要修改现有代码。抽象工厂模式适用于什么场景？

用户：需要创建产品族的时候？

老师：是的！抽象工厂模式用于创建一系列相关或相互依赖的对象，比如不同操作系统的UI组件族。工厂模式的核心思想是什么？

用户：将创建逻辑封装起来？

老师：对的！工厂模式的核心是封装创建逻辑，让客户端通过工厂接口获取对象，而不需要知道具体的创建细节。

---

### 知识点69：设计模式-观察者模式

**对话：**

用户：什么是观察者模式？它有什么应用场景？

老师：观察者模式定义对象间的一对多依赖关系，当一个对象状态改变时，所有依赖它的对象都会收到通知。你能想到生活中的例子吗？

用户：订阅报纸、关注公众号？

老师：很好！这些都是观察者模式的典型例子。观察者模式包含哪些角色？

用户：被观察者（主题）、观察者？

老师：对的！观察者模式包含：Subject（被观察者/主题）、Observer（观察者）、ConcreteSubject（具体主题）、ConcreteObserver（具体观察者）。你能说说它们之间的关系吗？

用户：Subject维护Observer列表，状态改变时通知所有Observer？

老师：是的！Subject提供注册、删除、通知观察者的方法；Observer定义更新接口。Java中有没有现成的观察者模式实现？

用户：好像有Observer和Observable类？

老师：对！Java提供了java.util.Observer接口和Observable类，但Observable在Java 9中被标记为过时。现在更推荐使用什么方式？

用户：事件监听机制？

老师：是的！现在更推荐使用事件监听机制，比如JavaFX、Spring的事件机制都是观察者模式的应用。观察者模式有什么优点和缺点？

用户：优点是解耦，缺点是可能性能问题？

老师：对的！优点是Subject和Observer解耦，符合开闭原则；缺点是如果观察者很多，通知可能耗时，而且观察者不知道Subject如何变化，可能导致调试困难。

---

### 知识点70：设计模式-策略模式

**对话：**

用户：什么是策略模式？它解决了什么问题？

老师：策略模式定义一系列算法，把它们封装起来，并且使它们可以相互替换。你能想到什么场景适合用策略模式？

用户：排序算法、支付方式？

老师：很好！策略模式适用于多种算法可以互换的场景。策略模式包含哪些角色？

用户：策略接口、具体策略、上下文？

老师：对的！策略模式包含：Strategy（策略接口）、ConcreteStrategy（具体策略实现）、Context（上下文）。Context的作用是什么？

用户：持有策略对象，调用策略方法？

老师：是的！Context持有一个Strategy引用，可以在运行时切换不同的策略。你能举个排序的例子吗？

用户：比如冒泡排序、快速排序、归并排序？

老师：对！我们可以定义SortStrategy接口，有BubbleSort、QuickSort等实现，Context根据需要选择不同的排序策略。策略模式和工厂模式有什么区别？

用户：策略模式关注算法，工厂模式关注创建？

老师：对的！策略模式关注算法的选择和替换，工厂模式关注对象的创建。策略模式的核心思想是什么？

用户：将算法封装成独立的类？

老师：是的！策略模式的核心是将算法封装成独立的类，使它们可以相互替换，而不影响使用算法的客户端。这提高了代码的灵活性和可维护性。

---

### 知识点71：JDBC基础

**对话：**

用户：什么是JDBC？它有什么作用？

老师：JDBC（Java Database Connectivity）是Java程序连接和操作数据库的标准API。你能想到JDBC的主要作用吗？

用户：执行SQL语句、处理结果集？

老师：对的！JDBC的主要功能包括：连接数据库、执行SQL语句、处理结果集、管理事务。JDBC的核心接口有哪些？

用户：Connection、Statement、ResultSet？

老师：是的！JDBC的核心接口包括：
- Driver：数据库驱动接口
- Connection：数据库连接接口
- Statement：执行SQL语句的接口
- PreparedStatement：预编译SQL语句接口
- ResultSet：结果集接口

你能说说使用JDBC的基本步骤吗？

用户：加载驱动、创建连接、执行SQL、处理结果、关闭资源？

老师：完全正确！使用JDBC的基本步骤是：
1. 加载数据库驱动
2. 获取数据库连接
3. 创建Statement或PreparedStatement
4. 执行SQL语句
5. 处理结果集
6. 关闭资源

PreparedStatement和Statement有什么区别？

用户：PreparedStatement可以防止SQL注入，性能更好？

老师：对的！PreparedStatement是预编译的，可以防止SQL注入，性能更好，而且支持参数化查询。JDBC事务是如何管理的？

用户：Connection的setAutoCommit、commit、rollback？

老师：是的！Connection提供了事务管理方法：setAutoCommit(false)关闭自动提交、commit()提交事务、rollback()回滚事务。JDBC有什么缺点？

用户：代码繁琐、资源管理麻烦？

老师：对的！JDBC代码繁琐，需要手动管理资源，容易出错。所以现在通常使用ORM框架如MyBatis、Hibernate来简化数据库操作。

---

### 知识点72：数据库连接池

**对话：**

用户：什么是数据库连接池？为什么要用连接池？

老师：连接池是预先创建并维护一组数据库连接，应用程序需要时从池中获取，使用后归还。你能想到这样做的好处吗？

用户：避免频繁创建和销毁连接，提高性能？

老师：对的！连接池的主要优点是：减少连接创建和销毁的开销、提高资源利用率、控制连接数量、提高系统性能。连接池的核心参数有哪些？

用户：初始连接数、最大连接数、超时时间？

老师：是的！连接池的核心参数包括：
- initialSize：初始连接数
- maxActive：最大活跃连接数
- maxIdle：最大空闲连接数
- minIdle：最小空闲连接数
- maxWait：获取连接的最大等待时间

你知道有哪些常用的连接池吗？

用户：Druid、HikariCP、C3P0？

老师：对的！常用的连接池有：
- Druid：阿里巴巴开源，功能强大，监控完善
- HikariCP：性能优秀，轻量级
- C3P0：老牌连接池，配置简单

HikariCP为什么性能好？

用户：代码优化、减少锁竞争？

老师：是的！HikariCP通过精简代码、优化锁机制、使用FastList等优化手段，实现了高性能。连接池的工作原理是什么？

用户：应用请求连接时从池中获取，用完后归还？

老师：对的！连接池的工作流程是：
1. 应用请求连接时，从池中获取可用连接
2. 如果池中没有可用连接且未达到最大值，创建新连接
3. 使用完毕后将连接归还到池中
4. 连接池定期检查空闲连接，清理超时连接

连接池如何保证连接的可用性？

用户：定期测试连接有效性？

老师：是的！连接池会定期测试连接的有效性，比如执行简单的SQL语句，发现无效连接会关闭并创建新连接。这保证了应用获取的连接都是可用的。

---

### 知识点73：序列化与反序列化

**对话：**

用户：什么是序列化和反序列化？

老师：序列化是将对象转换为字节流的过程，以便保存到文件、数据库或进行网络传输。反序列化是将字节流转换回对象的过程。你能想到序列化的应用场景吗？

用户：保存对象状态、网络传输、缓存？

老师：很好！序列化的应用场景包括：持久化存储、网络传输、进程间通信、缓存。Java中如何实现序列化？

用户：实现Serializable接口？

老师：对的！Java中实现序列化的方式是实现Serializable接口，这个接口是一个标记接口，没有方法。序列化ID有什么作用？

用户：用于版本控制？

老师：是的！serialVersionUID用于版本控制，反序列化时会检查serialVersionUID是否一致，不一致会抛出异常。不指定serialVersionUID会怎样？

用户：JVM自动生成，修改类后可能不一致？

老师：对的！如果不指定serialVersionUID，JVM会根据类的详细信息自动生成，类结构变化后serialVersionUID会改变，导致反序列化失败。所以建议显式指定serialVersionUID。

哪些字段不参与序列化？

用户：static和transient修饰的字段？

老师：对的！static字段属于类，不属于对象，不参与序列化；transient字段标记为不序列化。Externalizable接口和Serializable有什么区别？

用户：Externalizable需要实现读写方法，更灵活？

老师：是的！Externalizable接口需要实现writeExternal和readExternal方法，提供了更精细的控制，性能也更好，但需要手动处理所有字段的序列化。序列化有什么安全风险？

用户：可能被反序列化攻击？

老师：对的！反序列化可能被恶意利用，执行任意代码。所以要注意：不要反序列化不可信的数据、使用白名单机制、使用安全的序列化框架如Protobuf、Kryo等。

---

### 知识点74：RPC框架基础

**对话：**

用户：什么是RPC？它解决了什么问题？

老师：RPC（Remote Procedure Call）远程过程调用，让调用远程服务像调用本地方法一样简单。你能想到RPC的作用吗？

用户：简化分布式系统的开发？

老师：对的！RPC的主要作用是：屏蔽网络通信细节、简化分布式开发、提高开发效率。RPC的核心流程是什么？

用户：客户端调用、网络传输、服务端执行、返回结果？

老师：是的！RPC的基本流程是：
1. 客户端调用本地存根
2. 存根将参数序列化
3. 通过网络发送到服务端
4. 服务端反序列化参数
5. 调用本地服务
6. 将结果序列化返回
7. 客户端反序列化结果

RPC和HTTP有什么区别？

用户：RPC更高效，协议更轻量？

老师：对的！RPC通常使用二进制协议，性能更好；HTTP基于文本，通用性强。RPC更适合内部服务调用，HTTP更适合对外接口。你知道哪些RPC框架吗？

用户：Dubbo、gRPC、Spring Cloud OpenFeign？

老师：是的！常见的RPC框架包括：
- Dubbo：阿里开源，适合微服务场景
- gRPC：基于HTTP/2和Protocol Buffers
- Spring Cloud OpenFeign：基于REST的轻量级RPC
- Thrift：Apache的跨语言RPC框架

RPC如何实现服务发现？

用户：注册中心？

老师：对的！RPC通常使用注册中心（如Nacos、Zookeeper、Eureka）来管理服务地址。服务启动时注册到注册中心，客户端从注册中心获取服务地址。RPC如何实现负载均衡？

用户：轮询、随机、权重等策略？

老师：是的！RPC支持多种负载均衡策略：轮询、随机、权重、最少连接、一致性哈希等。RPC如何保证可靠性？

用户：重试、熔断、限流？

老师：对的！RPC通过重试机制、熔断器、限流、超时控制等机制保证可靠性。这些机制在分布式系统中非常重要。

---

### 知识点75：分布式基础概念

**对话：**

用户：什么是分布式系统？它有什么特点？

老师：分布式系统是由多个独立的计算机节点组成的系统，这些节点通过网络通信，协同完成共同的任务。你能想到分布式系统的特点吗？

用户：多节点、网络通信、并发？

老师：对的！分布式系统的特点包括：多节点部署、网络通信、并发性、透明性、可扩展性、可靠性。分布式系统有哪些优势？

用户：可扩展、高可用、高性能？

老师：是的！分布式系统的优势是：可扩展性强、高可用性、高性能、容错能力强。分布式系统面临哪些挑战？

用户：网络延迟、数据一致性、分布式事务？

老师：对的！分布式系统的主要挑战包括：
- 网络延迟和故障
- 数据一致性
- 分布式事务
- 节点协调
- 容错和恢复

CAP理论是什么？

用户：一致性、可用性、分区容错性？

老师：对的！CAP理论指出分布式系统不能同时满足一致性、可用性、分区容错性，最多只能同时满足两个。你能解释一下这三个概念吗？

用户：一致性是所有节点数据相同，可用性是总能响应，分区容错是网络分区时仍能工作？

老师：完全正确！一致性指所有节点在同一时间看到相同的数据；可用性指每次请求都能得到响应；分区容错指系统在网络分区时仍能继续工作。BASE理论是什么？

用户：基本可用、软状态、最终一致性？

老师：是的！BASE理论是CAP的权衡，包括：基本可用、软状态、最终一致性。BASE理论强调可用性和最终一致性，适合大规模分布式系统。分布式事务有哪些解决方案？

用户：两阶段提交、TCC、本地消息表？

老师：对的！分布式事务的解决方案包括：
- 2PC（两阶段提交）：强一致性，性能较差
- TCC（Try-Confirm-Cancel）：性能好，实现复杂
- 本地消息表：最终一致性，实现简单
- Saga：长事务，适合业务流程

分布式锁有哪些实现方式？

用户：Redis、Zookeeper、数据库？

老师：是的！分布式锁的实现方式包括：
- Redis：使用SETNX命令，性能好
- Zookeeper：利用临时顺序节点，可靠性高
- 数据库：利用唯一索引，实现简单但性能差

---

### 知识点76：微服务基础概念

**对话：**

用户：什么是微服务？它和单体架构有什么区别？

老师：微服务是一种架构风格，将应用拆分为一组小型服务，每个服务运行在独立的进程中，通过轻量级通信机制协作。你能想到微服务的特点吗？

用户：服务拆分、独立部署、技术栈灵活？

老师：对的！微服务的特点包括：服务拆分、独立部署、技术栈灵活、去中心化、自动化部署。微服务架构有哪些优势？

用户：可扩展、易维护、技术选型灵活？

老师：是的！微服务的优势包括：可扩展性强、易于维护、技术选型灵活、团队自治、容错性好。微服务架构面临哪些挑战？

用户：服务治理、分布式事务、运维复杂？

老师：对的！微服务的主要挑战包括：
- 服务治理：服务发现、配置管理、负载均衡
- 分布式事务：数据一致性
- 运维复杂：监控、日志、部署
- 测试困难：服务间依赖
- 网络延迟：服务间通信开销

微服务和SOA有什么区别？

用户：微服务更细粒度，更轻量？

老师：是的！微服务是SOA的演进，服务粒度更细，通信更轻量，部署更灵活，技术栈更自由。微服务如何拆分？

用户：按业务领域、按功能模块？

老师：对的！微服务的拆分原则包括：按业务领域拆分（DDD）、单一职责原则、高内聚低耦合。拆分时要考虑服务边界、数据一致性、团队结构等因素。微服务如何通信？

用户：同步通信和异步通信？

老师：是的！微服务的通信方式包括：
- 同步通信：REST、gRPC、Dubbo
- 异步通信：消息队列（RabbitMQ、Kafka）

同步通信简单直接，异步通信解耦性强。微服务如何保证数据一致性？

用户：最终一致性、补偿机制？

老师：对的！微服务通常采用最终一致性，通过Saga模式、TCC、本地消息表等机制保证数据一致性。微服务如何监控？

用户：日志、指标、链路追踪？

老师：是的！微服务的监控包括：
- 日志收集：ELK（Elasticsearch、Logstash、Kibana）
- 指标监控：Prometheus、Grafana
- 链路追踪：SkyWalking、Zipkin、Jaeger

这些监控工具帮助我们了解系统的运行状态，快速定位问题。

---

### 知识点77：Spring框架基础

**对话：**

用户：什么是Spring框架？它解决了什么问题？

老师：Spring是一个轻量级的Java开发框架，提供了全面的基础设施支持，简化Java开发。你能想到Spring的核心功能吗？

用户：IOC、AOP、事务管理？

老师：对的！Spring的核心功能包括：
- IOC（控制反转）：依赖注入
- AOP（面向切面编程）
- 事务管理
- MVC框架
- 数据访问集成

什么是IOC？

用户：控制反转，依赖注入？

老师：是的！IOC（Inversion of Control）控制反转，将对象的创建和管理交给Spring容器。依赖注入是IOC的一种实现方式。你能举例说明吗？

用户：比如Service需要DAO，Spring自动注入DAO？

老师：对的！传统方式是Service自己创建DAO，IOC方式是Spring容器创建DAO并注入给Service。依赖注入有哪些方式？

用户：构造器注入、Setter注入、字段注入？

老师：是的！依赖注入的方式包括：
- 构造器注入：推荐，保证不可变性
- Setter注入：灵活，可选依赖
- 字段注入：简单，但不推荐

什么是AOP？

用户：面向切面编程，将横切关注点分离？

老师：对的！AOP（Aspect-Oriented Programming）面向切面编程，将横切关注点（如日志、事务、权限）从业务逻辑中分离。AOP的核心概念有哪些？

用户：切面、连接点、通知、切点？

老师：是的！AOP的核心概念包括：
- Aspect（切面）：横切关注点的模块化
- Join Point（连接点）：程序执行的某个位置
- Advice（通知）：在连接点执行的动作
- Pointcut（切点）：匹配连接点的表达式
- Weaving（织入）：将切面应用到目标对象的过程

AOP有哪些类型的通知？

用户：前置、后置、环绕、异常、最终？

老师：对的！AOP的通知类型包括：
- @Before：前置通知
- @After：后置通知
- @Around：环绕通知
- @AfterReturning：返回通知
- @AfterThrowing：异常通知

Spring如何管理事务？

用户：声明式事务、编程式事务？

老师：是的！Spring的事务管理包括：
- 声明式事务：使用@Transactional注解，推荐
- 编程式事务：手动管理，灵活但复杂

Spring事务的传播行为有哪些？

用户：REQUIRED、REQUIRES_NEW、SUPPORTS等？

老师：对的！Spring的传播行为包括：
- REQUIRED：默认，如果存在事务则加入，否则新建
- REQUIRES_NEW：总是新建事务
- SUPPORTS：支持事务，如果没有就以非事务方式执行
- NOT_SUPPORTED：以非事务方式执行
- MANDATORY：必须在事务中执行
- NEVER：不能在事务中执行
- NESTED：嵌套事务

---

### 知识点78：MyBatis基础

**对话：**

用户：什么是MyBatis？它有什么特点？

老师：MyBatis是一个优秀的持久层框架，它支持定制化SQL、存储过程以及高级映射。你能想到MyBatis的特点吗？

用户：SQL与代码分离、动态SQL、结果映射？

老师：对的！MyBatis的特点包括：
- SQL与代码分离：XML或注解配置SQL
- 动态SQL：灵活的条件查询
- 结果映射：自动映射结果集到对象
- 缓存机制：一级缓存和二级缓存
- 插件机制：可扩展

MyBatis的核心组件有哪些？

用户：SqlSessionFactory、SqlSession、Mapper？

老师：是的！MyBatis的核心组件包括：
- SqlSessionFactory：创建SqlSession的工厂
- SqlSession：执行SQL、管理事务
- Mapper：映射SQL语句的接口
- Configuration：配置信息

MyBatis如何执行SQL？

用户：通过Mapper接口或SqlSession？

老师：对的！MyBatis执行SQL的方式包括：
- Mapper接口：推荐，类型安全
- SqlSession：直接执行，灵活

你能举个Mapper接口的例子吗？

用户：比如UserMapper有selectById方法？

老师：对的！比如：
```java
public interface UserMapper {
    User selectById(Long id);
    List<User> selectAll();
    void insert(User user);
    void update(User user);
    void delete(Long id);
}
```

对应的XML配置SQL语句。MyBatis的动态SQL有哪些标签？

用户：if、choose、foreach、where？

老师：是的！MyBatis的动态SQL标签包括：
- if：条件判断
- choose/when/otherwise：多选一
- foreach：循环
- where/set：智能处理WHERE/SET
- trim：自定义前缀后缀

你能举个if的例子吗？

用户：比如根据条件动态拼接WHERE？

老师：对的！比如：
```xml
<select id="selectByCondition" resultType="User">
    SELECT * FROM user
    <where>
        <if test="name != null">
            AND name = #{name}
        </if>
        <if test="age != null">
            AND age = #{age}
        </if>
    </where>
</select>
```

MyBatis的缓存机制是怎样的？

用户：一级缓存默认开启，二级缓存需要配置？

老师：对的！MyBatis的缓存包括：
- 一级缓存：SqlSession级别，默认开启
- 二级缓存：Mapper级别，需要配置

一级缓存的作用域是SqlSession，同一个SqlSession执行相同SQL会从缓存获取。二级缓存的作用域是Mapper，多个SqlSession可以共享缓存。MyBatis如何处理关联查询？

用户：association、collection？

老师：对的！MyBatis处理关联查询的方式包括：
- association：一对一关联
- collection：一对多关联

比如用户和订单的关系，用户有一个订单用association，用户有多个订单用collection。MyBatis如何防止SQL注入？

用户：使用#{}而不是${}？

老师：对的！#{}使用预编译，防止SQL注入；${}是字符串拼接，有SQL注入风险。所以SQL参数要用#{}，表名、字段名等可以用${}。

---

### 知识点79：Redis基础

**对话：**

用户：什么是Redis？它有什么特点？

老师：Redis是一个开源的内存数据结构存储系统，可以用作数据库、缓存和消息中间件。你能想到Redis的特点吗？

用户：基于内存、速度快、支持多种数据结构？

老师：对的！Redis的特点包括：
- 基于内存：读写速度快
- 支持多种数据结构：String、List、Set、Hash、ZSet等
- 支持持久化：RDB和AOF
- 支持主从复制：高可用
- 支持集群：分布式

Redis支持哪些数据结构？

用户：String、List、Set、Hash、ZSet？

老师：是的！Redis的数据结构包括：
- String：字符串
- List：列表
- Set：集合
- Hash：哈希
- ZSet：有序集合
- Bitmap：位图
- HyperLogLog：基数统计
- Geo：地理位置

你能说说每种数据结构的应用场景吗？

用户：String缓存，List消息队列，Set去重，Hash对象，ZSet排行榜？

老师：完全正确！
- String：缓存、计数器、分布式锁
- List：消息队列、最新列表
- Set：去重、共同好友
- Hash：对象存储、购物车
- ZSet：排行榜、延时队列

Redis的持久化方式有哪些？

用户：RDB和AOF？

老师：对的！Redis的持久化方式包括：
- RDB（Redis Database）：快照，定时保存
- AOF（Append Only File）：日志，记录写操作

RDB的优点是文件小、恢复快，缺点是可能丢失数据；AOF的优点是数据完整，缺点是文件大、恢复慢。可以同时使用两种方式。Redis的主从复制是怎样的？

用户：主节点写入，从节点读取？

老师：是的！Redis主从复制的工作流程是：
1. 从节点连接主节点，发送SYNC命令
2. 主节点执行BGSAVE，生成RDB文件
3. 主节点将RDB文件发送给从节点
4. 从节点加载RDB文件
5. 主节点将后续写命令发送给从节点

主从复制可以实现读写分离，提高读取性能。Redis集群有哪些模式？

用户：主从复制、哨兵、Cluster？

老师：对的！Redis的高可用方案包括：
- 主从复制：读写分离
- 哨兵（Sentinel）：自动故障转移
- 集群（Cluster）：分片存储

哨兵监控主节点状态，主节点故障时自动选举新的主节点。Cluster将数据分片到多个节点，实现水平扩展。Redis如何实现分布式锁？

用户：SETNX命令？

老师：对的！Redis分布式锁使用SETNX（SET if Not eXists）命令，基本流程是：
1. 使用SETNX加锁，设置过期时间
2. 执行业务逻辑
3. 释放锁（DEL命令）

要注意设置过期时间防止死锁，释放锁时要验证锁的归属。Redis的缓存策略有哪些？

用户：过期策略、淘汰策略？

老师：对的！Redis的缓存策略包括：
- 过期策略：定期删除、惰性删除
- 淘汰策略：noeviction、allkeys-lru、allkeys-lfu等

过期策略是删除过期的key，淘汰策略是内存不足时删除哪些key。常用的淘汰策略是allkeys-lru（删除最近最少使用的key）。

---

### 知识点80：系统设计基础

**对话：**

用户：系统设计需要考虑哪些方面？

老师：系统设计是一个复杂的过程，需要考虑多个方面。你能想到系统设计的关键要素吗？

用户：功能需求、性能、可用性、扩展性？

老师：对的！系统设计的关键要素包括：
- 功能需求：系统要实现什么功能
- 性能：响应时间、吞吐量、并发量
- 可用性：系统正常运行的时间比例
- 扩展性：系统应对增长的能力
- 可靠性：系统的容错和恢复能力
- 安全性：数据保护和访问控制

系统设计的基本流程是什么？

用户：需求分析、架构设计、详细设计、实现？

老师：是的！系统设计的基本流程是：
1. 需求分析：明确功能和非功能需求
2. 架构设计：确定系统架构和技术选型
3. 详细设计：模块设计、接口设计、数据设计
4. 实现：编码开发
5. 测试：功能测试、性能测试
6. 部署：上线运维

如何进行容量估算？

用户：根据用户量、访问量、数据量估算？

老师：对的！容量估算需要考虑：
- 用户量：日活、月活
- 访问量：QPS（每秒查询数）、峰值QPS
- 数据量：存储容量、增长速度
- 带宽：上行、下行

比如一个日活100万的系统，假设每个用户每天访问10次，那么日访问量是1000万，QPS大约是1000万/86400≈116，峰值QPS可能是平时的2-3倍。如何设计高可用系统？

用户：负载均衡、冗余部署、故障转移？

老师：对的！高可用系统设计包括：
- 负载均衡：分散请求到多个服务器
- 冗余部署：多实例部署，避免单点故障
- 故障转移：自动检测和切换
- 熔断降级：保护系统，防止雪崩
- 限流：控制访问量，防止过载

负载均衡有哪些算法？

用户：轮询、随机、最少连接、一致性哈希？

老师：是的！负载均衡算法包括：
- 轮询：依次分配
- 随机：随机选择
- 最少连接：选择连接数最少的
- 一致性哈希：相同请求到同一服务器
- 加权轮询：根据权重分配

如何设计高并发系统？

用户：缓存、异步、分库分表？

老师：对的！高并发系统设计包括：
- 缓存：减少数据库访问
- 异步：消息队列解耦
- 分库分表：水平扩展
- CDN：静态资源加速
- 读写分离：分散数据库压力

你能举个电商秒杀的例子吗？

用户：Redis缓存、消息队列、限流？

老师：对的！电商秒杀系统设计：
- 前端：静态化、CDN、限流
- 缓存：Redis预热库存
- 消息队列：异步处理订单
- 数据库：分库分表、读写分离
- 降级：保护核心功能

系统设计有哪些常见的设计原则？

用户：高内聚低耦合、单一职责、开闭原则？

老师：是的！系统设计的原则包括：
- 高内聚低耦合：模块独立，易于维护
- 单一职责：每个模块只做一件事
- 开闭原则：对扩展开放，对修改关闭
- 最小化原则：简单设计
- 分层设计：表现层、业务层、数据层

好的设计原则让系统更易维护和扩展。

---

## 学习总结

今天学习了Java高级特性与框架基础，包括：

1. **注解与动态代理**：理解了注解的生命周期和应用场景，掌握了动态代理的实现原理和应用
2. **设计模式**：学习了单例、工厂、观察者、策略等常用设计模式的思想和应用
3. **数据库相关**：掌握了JDBC基础、连接池原理、序列化机制
4. **分布式与微服务**：了解了RPC、分布式系统、微服务架构的核心概念
5. **框架基础**：学习了Spring的IOC/AOP、MyBatis的ORM映射、Redis的缓存应用
6. **系统设计**：掌握了系统设计的基本原则和高可用、高并发的设计思路

这些知识点是Java后端开发的重要基础，为深入学习框架和架构设计打下了坚实基础。接下来需要通过实际项目来巩固这些知识，并深入学习Spring Boot、Spring Cloud等现代框架。

**学习心得：**
- 注解和动态代理是框架开发的核心技术
- 设计模式提供了成熟的解决方案，要理解其思想而非死记硬背
- 分布式系统要权衡一致性和可用性，根据场景选择合适的方案
- 框架简化了开发，但要理解其底层原理
- 系统设计要综合考虑功能、性能、可用性、扩展性等多个方面
                                               ⾯渣逆袭 JVM篇第⼆版-让天下所有的⾯渣都能逆袭


前⾔                                                                 No. 1 / 95
                                ⾯渣逆袭 JVM篇第⼆版-让天下所有的⾯渣都能逆袭

前⾔                                                                                                

2.3 万字 115 张⼿绘图，详解 54 道 Java 虚拟机⾯试⾼频题（让天下没有难背的⼋股），⾯渣背会这些 JVM ⼋股
⽂，这次吊打⾯试官，我觉得稳了（⼿动 dog）。整理：沉默王⼆，戳转载链接，作者：三分恶，戳原⽂链接。

亮⽩版本更适合拿出来打印，这也是很多学⽣党喜欢的⽅式，打印出来背诵的效率会更⾼。


2024 年 12 ⽉ 30 ⽇开始着⼿第⼆版更新。

     对于⾼频题，会标注在《Java ⾯试指南（付费）》中出现的位置，哪家公司，原题是什么，并且会加                                        ，⽬
     录⼀⽬了然；如果你想节省时间的话，可以优先背诵这些题⽬，尽快做到知彼知⼰，百战不殆。

     区分⼋股精华回答版本和原理底层解释，让⼤家知其然知其所以然，同时⼜能做到⾯试时的⾼效回答。

     结合项⽬（技术派、pmhub）来组织语⾔，让⾯试官最⼤程度感受到你的诚意，⽽不是机械化的背诵。

     修复第⼀版中出现的问题，包括球友们的私信反馈，⽹站留⾔区的评论，以及 GitHub 仓库中的 issue，让这
     份⾯试指南更加完善。

     增加⼆哥编程星球的球友们拿到的⼀些 offer，对⾯渣逆袭的感谢，以及对简历修改的⼀些认可，以此来激励
     ⼤家，给⼤家更多信⼼。

     优化排版，增加⼿绘图，重新组织答案，使其更加⼝语化，从⽽更贴近⾯试官的预期。


                                             No. 2 / 95
                                ⾯渣逆袭 JVM篇第⼆版-让天下所有的⾯渣都能逆袭


由于 PDF 没办法⾃我更新，所以需要最新版的⼩伙伴，可以微信搜【沉默王⼆】，或者扫描/⻓按识别下⾯的⼆维
码，关注⼆哥的公众号，回复【222】即可拉取最新版本。


                                             No. 3 / 95
                                ⾯渣逆袭 JVM篇第⼆版-让天下所有的⾯渣都能逆袭

当然了，请允许我的⼀点点私⼼，那就是星球的 PDF 版本会⽐公众号早⼀个⽉时间，毕竟星球⽤户都付费过了，
我有必要让他们先享受到⼀点点福利。相信⼤家也都能理解，毕竟在线版是免费的，CDN、服务器、域名、OSS 
等等都是需要成本的。

更别说我付出的时间和精⼒了，⼤家觉得有帮助还请给个⼝碑，让你身边的同事、同学都能受益到。


我把⼆哥的 Java 进阶之路、JVM 进阶之路、并发编程进阶之路，以及所有⾯渣逆袭的版本都放进来了，涵盖 Java
基础、Java集合、Java并发、JVM、Spring、MyBatis、计算机⽹络、操作系统、MySQL、Redis、RocketMQ、分
布式、微服务、设计模式、Linux 等 16 个⼤的主题，共有 40 多万字，2000+张⼿绘图，可以说是诚意满满。

展示⼀下暗⿊版本的 PDF 吧，排版清晰，字体优雅，更加适合夜服，晚上看会更舒服⼀点。


                                             No. 4 / 95
                                ⾯渣逆袭 JVM篇第⼆版-让天下所有的⾯渣都能逆袭


⼀、引⾔                                                                                              

1.什么是 JVM?                                                                                        

JVM，也就是 Java 虚拟机，它是 Java 实现跨平台的基⽯。

程序运⾏之前，需要先通过编译器将 Java 源代码⽂件编译成 Java 字节码⽂件；

程序运⾏时，JVM 会对字节码⽂件进⾏逐⾏解释，翻译成机器码指令，并交给对应的操作系统去执⾏。


                                             No. 5 / 95
                                ⾯渣逆袭 JVM篇第⼆版-让天下所有的⾯渣都能逆袭


这样就实现了 Java ⼀次编译，处处运⾏的特性。

说说 JVM 的其他特性？                                                                                     

①、JVM 可以⾃动管理内存，通过垃圾回收器回收不再使⽤的对象并释放内存空间。

②、JVM 包含⼀个即时编译器 JIT，它可以在运⾏时将热点代码缓存到 codeCache 中，下次执⾏的时候不⽤再⼀⾏
⼀⾏的解释，⽽是直接执⾏缓存后的机器码，执⾏效率会⼤幅提⾼。


                                             No. 6 / 95
                                ⾯渣逆袭 JVM篇第⼆版-让天下所有的⾯渣都能逆袭


③、任何可以通过 Java 编译的语⾔，⽐如说 Groovy、Kotlin、Scala 等，都可以在 JVM 上运⾏。


为什么要学习 JVM？                                                                                       


                                             No. 7 / 95
                                ⾯渣逆袭 JVM篇第⼆版-让天下所有的⾯渣都能逆袭

学习 JVM 可以帮助我们开发者更好地优化程序性能、避免内存问题。

⽐如说了解 JVM 的内存模型和垃圾回收机制，可以帮助我们更合理地配置内存、减少 GC 停顿。

⽐如说掌握 JVM 的类加载机制可以帮助我们排查类加载冲突或异常。

再⽐如说，JVM 还提供了很多调试和监控⼯具，可以帮助我们分析内存和线程的使⽤情况，从⽽解决内存溢出内存
泄露等问题。

     1. Java ⾯试指南（付费）收录的京东同学 10 后端实习⼀⾯的原题：有了解 JVM 吗

     2. Java ⾯试指南（付费）收录的字节跳动同学 20 测开⼀⾯的原题：了解过 JVM 么？讲⼀下 JVM 的特性

2.说说 JVM 的组织架构（补充）                                                                                

   增补于 2024 年 03 ⽉ 08 ⽇。

推荐阅读：⼤⽩话带你认识 JVM

JVM ⼤致可以划分为三个部分：类加载器、运⾏时数据区和执⾏引擎。


① 类加载器，负责从⽂件系统、⽹络或其他来源加载 Class ⽂件，将 Class ⽂件中的⼆进制数据读⼊到内存当中。


                                             No. 8 / 95
                                ⾯渣逆袭 JVM篇第⼆版-让天下所有的⾯渣都能逆袭

② 运⾏时数据区，JVM 在执⾏ Java 程序时，需要在内存中分配空间来处理各种数据，这些内存区域按照 Java 虚拟
机规范可以划分为⽅法区、堆、虚拟机栈、程序计数器和本地⽅法栈。

③ 执⾏引擎，也是 JVM 的⼼脏，负责执⾏字节码。它包括⼀个虚拟处理器、即时编译器 JIT 和垃圾回收器。

     1. Java ⾯试指南（付费）收录的腾讯 Java 后端实习⼀⾯原题：说说 JVM 的组织架构

     2. Java ⾯试指南（付费）收录的得物⾯经同学 9 ⾯试题⽬原题：JVM的架构，具体阐述⼀下各个部分的功
        能？
⼆、内存管理                                                                                            

3.    能说⼀下 JVM 的内存区域吗？                                                                            

推荐阅读：深⼊理解 JVM 的运⾏时数据区

按照 Java 虚拟机规范，JVM 的内存区域可以细分为                程序计数器    、 虚拟机栈    、 本地⽅法栈    、 堆  和 ⽅法区   。


其中   ⽅法区  和  堆 是线程共享的，       虚拟机栈   、 本地⽅法栈     和 程序计数器    是线程私有的。

                                             No. 9 / 95
                                ⾯渣逆袭 JVM篇第⼆版-让天下所有的⾯渣都能逆袭

介绍⼀下程序计数器？                                                                                        

程序计数器也被称为 PC 寄存器，是⼀块较⼩的内存空间。它可以看作是当前线程所执⾏的字节码⾏号指示器。

介绍⼀下 Java 虚拟机栈？                                                                                   

Java 虚拟机栈的⽣命周期与线程相同。

当线程执⾏⼀个⽅法时，会创建⼀个对应的栈帧，⽤于存储局部变量表、操作数栈、动态链接、⽅法出⼝等信息，
然后栈帧会被压⼊虚拟机栈中。当⽅法执⾏完毕后，栈帧会从虚拟机栈中移除。


⼀个什么都没有的空⽅法，空的参数都没有，那局部变量表⾥有没有变量？                                                                 

对于静态⽅法，由于不需要访问实例对象 this，因此在局部变量表中不会有任何变量。


                                             No. 10 / 95
                                ⾯渣逆袭 JVM篇第⼆版-让天下所有的⾯渣都能逆袭

对于⾮静态⽅法，即使是⼀个完全空的⽅法，局部变量表中也会有⼀个⽤于存储 this 引⽤的变量。this 引⽤指向当
前实例对象，在⽅法调⽤时被隐式传⼊。

详细解释⼀下：

⽐如说有这样⼀段代码：

  public class VarDemo1 {
      public void emptyMethod() {
          // 什么都没有
      }

      public static void staticEmptyMethod() {
          // 什么都没有
      }
  }

⽤  javap -v VarDemo1  命令查看编译后的字节码，就可以在 emptyMethod 中看到这样的内容：


这⾥的    locals=1  表示局部变量表有⼀个变量，即 this，Slot 0 位置存储了 this 引⽤。

⽽在静态⽅法 staticEmptyMethod 中，你会看到这样的内容：


                                             No. 11 / 95
                                ⾯渣逆袭 JVM篇第⼆版-让天下所有的⾯渣都能逆袭

这⾥的 locals=0 表示局部变量表为空，因为静态⽅法属于类级别⽅法，不需要 this 引⽤，也就没有局部变量。

介绍⼀下本地⽅法栈？                                                                                        

本地⽅法栈与虚拟机栈相似，区别在于虚拟机栈是为 JVM 执⾏ Java 编写的⽅法服务的，⽽本地⽅法栈是为 Java 调
⽤本地 native ⽅法服务的，通常由 C/C++ 编写。

在本地⽅法栈中，主要存放了 native ⽅法的局部变量、动态链接和⽅法出⼝等信息。当⼀个 Java 程序调⽤⼀个 
native ⽅法时，JVM 会切换到本地⽅法栈来执⾏这个⽅法。

介绍⼀下本地⽅法栈的运⾏场景？                                                                                   

当 Java 应⽤需要与操作系统底层或硬件交互时，通常会⽤到本地⽅法栈。

⽐如调⽤操作系统的特定功能，如内存管理、⽂件操作、系统时间、系统调⽤等。

详细说明⼀下：

⽐如说获取系统时间的           System.currentTimeMillis()  ⽅法就是调⽤本地⽅法，来获取操作系统当前时间的。


再⽐如 JVM ⾃身的⼀些底层功能也需要通过本地⽅法来实现。像 Object 类中的                          hashCode()  ⽅法、   clone()  ⽅
法等。


                                             No. 12 / 95
                                ⾯渣逆袭 JVM篇第⼆版-让天下所有的⾯渣都能逆袭


native ⽅法解释⼀下？                                                                                    

推荐阅读：⼿把⼿教你⽤ C语⾔实现 Java native 本地⽅法

native ⽅法是在 Java 中通过 native 关键字声明的，⽤于调⽤⾮ Java 语⾔，如 C/C++ 编写的代码。Java 可以通过 
JNI，也就是 Java Native Interface 与底层系统、硬件设备、或者本地库进⾏交互。

介绍⼀下 Java 堆？                                                                                      

堆是 JVM 中最⼤的⼀块内存区域，被所有线程共享，在 JVM 启动时创建，主要⽤来存储 new 出来的对象。


                                             No. 13 / 95
                                ⾯渣逆袭 JVM篇第⼆版-让天下所有的⾯渣都能逆袭

Java 中“⼏乎”所有的对象都会在堆中分配，堆也是垃圾收集器管理的⽬标区域。

从内存回收的⻆度来看，由于垃圾收集器⼤部分都是基于分代收集理论设计的，所以堆⼜被细分为                                        新⽣代   、 ⽼年
代  、 Eden空间  、 From Survivor空间   、 To Survivor空间  等。


随着 JIT 编译器的发展和逃逸技术的逐渐成熟，“所有的对象都会分配到堆上”就不再那么绝对了。

从 JDK 7 开始，JVM 默认开启了逃逸分析，意味着如果某些⽅法中的对象引⽤没有被返回或者没有在⽅法体外使
⽤，也就是未逃逸出去，那么对象可以直接在栈上分配内存。

堆和栈的区别是什么？                                                                                        

堆属于线程共享的内存区域，⼏乎所有 new 出来的对象都会堆上分配，⽣命周期不由单个⽅法调⽤所决定，可以
在⽅法调⽤结束后继续存在，直到不再被任何变量引⽤，最后被垃圾收集器回收。

栈属于线程私有的内存区域，主要存储局部变量、⽅法参数、对象引⽤等，通常随着⽅法调⽤的结束⽽⾃动释放，
不需要垃圾收集器处理。

介绍⼀下⽅法区？                                                                                          

⽅法区并不真实存在，属于 Java 虚拟机规范中的⼀个逻辑概念，⽤于存储已被 JVM 加载的类信息、常量、静态变
量、即时编译器编译后的代码缓存等。

在 HotSpot 虚拟机中，⽅法区的实现称为永久代 PermGen，但在 Java 8 及之后的版本中，已经被元空间 
Metaspace 所替代。

变量存在堆栈的什么位置？                                                                                      

对于局部变量，它存储在当前⽅法栈帧中的局部变量表中。当⽅法执⾏完毕，栈帧被回收，局部变量也会被释放。

  public void method() {
      int localVar = 100;  // 局部变量，存储在栈帧中的局部变量表⾥
  }


                                             No. 14 / 95
                                ⾯渣逆袭 JVM篇第⼆版-让天下所有的⾯渣都能逆袭

对于静态变量来说，它存储在 Java 虚拟机规范中的⽅法区中，在 Java 7 中是永久带，在 Java8 及以后 是元空间。

  public class StaticVarDemo {
      public static int staticVar = 100;  // 静态变量，存储在⽅法区中
  }

     1. Java ⾯试指南（付费）收录的京东同学 10 后端实习⼀⾯的原题：堆和栈的区别是什么

     2. Java ⾯试指南（付费）收录的⽐亚迪⾯经同学 3 Java 技术⼀⾯⾯试原题：介绍⼀下 JVM 运⾏时数据区

     3. Java ⾯试指南（付费）收录的字节跳动⾯经同学 1 Java 后端技术⼀⾯⾯试原题：讲⼀下 JVM 内存结
        构？

     4. Java ⾯试指南（付费）收录的京东⾯经同学 1 Java 技术⼀⾯⾯试原题：说说 JVM 运⾏时数据区

     5. Java ⾯试指南（付费）收录的美团⾯经同学 2 Java 后端技术⼀⾯⾯试原题：JVM 内存结构了解吗？

     6. Java ⾯试指南（付费）收录的快⼿⾯经同学 1 部⻔主站技术部⾯试原题：请说⼀下 Java 的内存区域，
        程序计数器等？

     7. Java ⾯试指南（付费）收录的字节跳动⾯经同学 8 Java 后端实习⼀⾯⾯试原题：jvm 内存分布，有垃
        圾回收的是哪些地⽅

     8. Java ⾯试指南（付费）收录的得物⾯经同学 8 ⼀⾯⾯试原题：说⼀说 jvm 内存区域

     9. Java ⾯试指南（付费）收录的美团⾯经同学 3 Java 后端技术⼀⾯⾯试原题：jmm 内存模型 栈 ⽅法区存
        放的是什么

    10. Java ⾯试指南（付费）收录的收钱吧⾯经同学 1 Java 后端⼀⾯⾯试原题：你提到了栈帧，那局部变量
        表除了栈帧还有什么？⼀个什么都没有的空⽅法，完全空的参数什么都没有，那局部变量表⾥有没有变
        量？

    11. Java ⾯试指南（付费）收录的招银⽹络科技⾯经同学 9 Java 后端技术⼀⾯⾯试原题：Java堆内存和栈内
        存的区别

    12. Java ⾯试指南（付费）收录的 OPPO ⾯经同学 1 ⾯试原题：说⼀下JVM内存模型

    13. Java ⾯试指南（付费）收录的深信服⾯经同学 3 Java 后端线下⼀⾯⾯试原题：JVM变量存在堆栈的位
        置？

    14. Java ⾯试指南（付费）收录的TP联洲同学 5 Java 后端⼀⾯的原题：Jvm内存区域，本地⽅法栈的运⾏场
        景，Native⽅法解释⼀下

    15. Java ⾯试指南（付费）收录的字节跳动同学 17 后端技术⾯试原题：jvm结构 运⾏时数据区有什么结构 
        堆存什么

    16. Java ⾯试指南（付费）收录的腾讯⾯经同学 29 Java 后端⼀⾯原题：new⼀个对象存放在哪⾥？（运⾏
        时数据区），局部变量存在JVM哪⾥

4.说⼀下 JDK 1.6、1.7、1.8 内存区域的变化？                                                                    

JDK 1.6 使⽤永久代来实现⽅法区：


                                             No. 15 / 95
                                ⾯渣逆袭 JVM篇第⼆版-让天下所有的⾯渣都能逆袭


JDK 1.7 时仍然是永久带，但发⽣了⼀些细微变化，⽐如将字符串常量池、静态变量存放到了堆上。


在 JDK 1.8 时，直接在内存中划出了⼀块区域，叫元空间，来取代之前放在 JVM 内存中的永久代，并将运⾏时常量
池、类常量池都移动到了元空间。


                                             No. 16 / 95
                                ⾯渣逆袭 JVM篇第⼆版-让天下所有的⾯渣都能逆袭


5.为什么使⽤元空间替代永久代？                                                                                  

客观上，永久代会导致 Java 应⽤程序更容易出现内存溢出的问题，因为它要受到 JVM 内存⼤⼩的限制。

HotSpot 虚拟机的永久代⼤⼩可以通过             -XX：MaxPermSize   参数来设置，32 位机器默认的⼤⼩为 64M，64 位的
机器则为 85M。

⽽ J9 和 JRockit 虚拟机就不存在这种限制，只要没有触碰到进程可⽤的内存上限，例如 32 位系统中的 4GB 限制，
就不会出问题。

主观上，当 Oracle 收购 BEA 获得了 JRockit 的所有权后，就准备把 JRockit 中的优秀功能移植到 HotSpot 中。

如 Java Mission Control 管理⼯具。

但因为两个虚拟机对⽅法区实现有差异，导致这项⼯作遇到了很多阻⼒。

考虑到 HotSpot 虚拟机未来的发展，JDK 6 的时候，开发团队就打算放弃永久代了。

JDK 7 的时候，前进了⼀⼩步，把原本放在永久代的字符串常量池、静态变量等移动到了堆中。

JDK 8 就终于完成了这项移出⼯作，这样的好处就是，元空间的⼤⼩不再受到 JVM 内存的限制，⽽是可以像 J9 和 
JRockit 那样，只要系统内存⾜够，就可以⼀直⽤。


                                             No. 17 / 95
                                ⾯渣逆袭 JVM篇第⼆版-让天下所有的⾯渣都能逆袭

6.    对象创建的过程了解吗？                                                                                 

当我们使⽤ new 关键字创建⼀个对象时，JVM ⾸先会检查 new 指令的参数是否能在常量池中定位到类的符号引
⽤，然后检查这个符号引⽤代表的类是否已被加载、解析和初始化。如果没有，就先执⾏类加载。


如果已经加载，JVM 会为对象分配内存完成初始化，⽐如数值类型的成员变量初始值是 0，布尔类型是 false，对
象类型是 null。

接下来会设置对象头，⾥⾯包含了对象是哪个类的实例、对象的哈希码、对象的 GC 分代年龄等信息。

最后，JVM 会执⾏构造⽅法          <init>  完成赋值操作，将成员变量赋值为预期的值，⽐如                     int age = 18 ，这样⼀
个对象就创建完成了。

对象的销毁过程了解吗？                                                                                       

当对象不再被任何引⽤指向时，就会变成垃圾。垃圾收集器会通过可达性分析算法判断对象是否存活，如果对象不
可达，就会被回收。

垃圾收集器通过标记清除、标记复制、标记整理等算法来回收内存，将对象占⽤的内存空间释放出来。

可以通过     java -XX:+PrintCommandLineFlags -version   和 java -XX:+PrintGCDetails -version   命令查
看 JVM 的 GC 收集器。


                                             No. 18 / 95
                                ⾯渣逆袭 JVM篇第⼆版-让天下所有的⾯渣都能逆袭


可以看到，我本机安装的 JDK 8 默认使⽤的是                Parallel Scavenge + Parallel Old 。

不同参数代表对应的垃圾收集器表单：

   新⽣代                    ⽼年代              JVM参数

   Serial                 Serial           -XX:+UseSerialGC

   Parallel Scavenge      Serial           -XX:+UseParallelGC -XX:-UseParallelOldGC

   Parallel Scavenge      Parallel Old     -XX:+UseParallelGC -XX:+UseParallelOldGC

   Parallel New           CMS              -XX:+UseParNewGC -XX:+UseConcMarkSweepGC

   G1                                      -XX:+UseG1GC

     1. Java ⾯试指南（付费）收录的⽐亚迪⾯经同学 3 Java 技术⼀⾯⾯试原题：对象创建到销毁的流程

     2. Java ⾯试指南（付费）收录的美团⾯经同学 2 Java 后端技术⼀⾯⾯试原题：说说创建对象的流程？

     3. Java ⾯试指南（付费）收录的携程⾯经同学 1 Java 后端技术⼀⾯⾯试原题：对象创建到销毁，内存如
        何分配的，（类加载和对象创建过程，CMS，G1 内存清理和分配）

7.堆内存是如何分配的？                                                                                      

在堆中为对象分配内存时，主要使⽤两种策略：指针碰撞和空闲列表。


                                             No. 19 / 95
                                ⾯渣逆袭 JVM篇第⼆版-让天下所有的⾯渣都能逆袭


指针碰撞适⽤于管理简单、碎⽚化较少的内存区域，如年轻代；⽽空闲列表适⽤于内存碎⽚化较严重或对象⼤⼩差
异较⼤的场景如⽼年代。

什么是指针碰撞？                                                                                          

假设堆内存是⼀个连续的空间，分为两个部分，⼀部分是已经被使⽤的内存，另⼀部分是未被使⽤的内存。

在分配内存时，Java 虚拟机会维护⼀个指针，指向下⼀个可⽤的内存地址，每次分配内存时，只需要将指针向后移
动⼀段距离，如果没有发⽣碰撞，就将这段内存分配给对象实例。

什么是空闲列表？                                                                                          

JVM 维护⼀个列表，记录堆中所有未占⽤的内存块，每个内存块都记录有⼤⼩和地址信息。

当有新的对象请求内存时，JVM 会遍历空闲列表，寻找⾜够⼤的空间来存放新对象。

分配后，如果选中的内存块未被完全利⽤，剩余的部分会作为⼀个新的内存块加⼊到空闲列表中。

     1. Java ⾯试指南（付费）收录的携程⾯经同学 1 Java 后端技术⼀⾯⾯试原题：对象创建到销毁，内存如
        何分配的，（类加载和对象创建过程，CMS，G1 内存清理和分配）


                                             No. 20 / 95
                                ⾯渣逆袭 JVM篇第⼆版-让天下所有的⾯渣都能逆袭

memo：2025 年 1 ⽉ 10 ⽇修改到此

8.new 对象时，堆会发⽣抢占吗？                                                                                

会。


new 对象时，指针会向右移动⼀个对象⼤⼩的距离，假如⼀个线程 A 正在给字符串对象 s 分配内存，另外⼀个线
程 B 同时为 ArrayList 对象 l 分配内存，两个线程就发⽣了抢占。

JVM 怎么解决堆内存分配的竞争问题？                                                                               

为了解决堆内存分配的竞争问题，JVM 为每个线程保留了⼀⼩块内存空间，被称为 TLAB，也就是线程本地分配缓
冲区，⽤于存放该线程分配的对象。


                                             No. 21 / 95
                                   ⾯渣逆袭 JVM篇第⼆版-让天下所有的⾯渣都能逆袭

当线程需要分配对象时，直接从 TLAB 中分配。只有当 TLAB ⽤尽或对象太⼤需要直接在堆中分配时，才会使⽤全
局分配指针。

这⾥简单测试⼀下 TLAB。

可以通过      java -XX:+PrintFlagsFinal -version | grep TLAB         命令查看当前 JVM 是否开启了 TLAB。


如果开启了 TLAB，会看到类似以下的输出，其中 bool UseTLAB 的值为 true。

我们编写⼀个简单的测试类，创建⼤量对象并强制触发垃圾回收，查看 TLAB 的使⽤情况。

  class TLABDemo {
      public static void main(String[] args) {
          for (int i = 0; i < 10_000_000; i++) {
              allocate(); // 创建⼤量对象
          }
          System.gc(); // 强制触发垃圾回收
      }

      private static void allocate() {
          // ⼩对象分配，通常会使⽤ TLAB
          byte[] bytes = new byte[64];
      }
  }

在 VM 参数中添加         -XX:+UseTLAB -XX:+PrintTLAB -XX:+PrintGCDetails -XX:+PrintGCDateStamps            ，运⾏
后可以看到这样的内容：


                                                  No. 22 / 95
                                ⾯渣逆袭 JVM篇第⼆版-让天下所有的⾯渣都能逆袭

     waste：未使⽤的 TLAB 空间。

     alloc：分配到 TLAB 的空间。

     refills：TLAB 被重新填充的次数。

可以看到，当前线程的 TLAB ⽬标⼤⼩为 10,496 KB（              desired_size: 10496KB  ）；未发⽣慢分配（        slow 
allocs: 0 ）；分配效率直接拉满（           alloc: 1.00000 52494KB ）。

当使⽤    -XX:-UseTLAB -XX:+PrintGCDetails   关闭 TLAB 时，会看到类似以下的输出：


直接出现了两次 GC，因为没有 TLAB，Eden 区更快被填满，导致年轻代 GC。年轻代 GC 频繁触发，⼀部分⻓⽣
命周期对象被晋升到⽼年代，间接导致⽼年代 GC 触发。

9.能说⼀下对象的内存布局吗？                                                                                   

好的。

对象的内存布局是由 Java 虚拟机规范定义的，但具体的实现细节各有不同，如 HotSpot 和 OpenJ9 就不⼀样。

就拿我们常⽤的 HotSpot 来说吧。

对象在内存中包括三部分：对象头、实例数据和对⻬填充。


                                             No. 23 / 95
                                ⾯渣逆袭 JVM篇第⼆版-让天下所有的⾯渣都能逆袭


说说对象头的作⽤？                                                                                         

对象头是对象存储在内存中的元信息，包含了Mark Word、类型指针等信息。

Mark Word 存储了对象的运⾏时状态信息，包括锁、哈希值、GC 标记等。在 64 位操作系统下占 8 个字节，32 
位操作系统下占 4 个字节。

类型指针指向对象所属类的元数据，也就是 Class 对象，⽤来⽀持多态、⽅法调⽤等功能。

除此之外，如果对象是数组类型，还会有⼀个额外的数组⻓度字段。占 4 个字节。

类型指针会被压缩吗？                                                                                        

类型指针可能会被压缩，以节省内存空间。⽐如说在开启压缩指针的情况下占 4 个字节，否则占 8 个字节。在 JDK 
8 中，压缩指针默认是开启的。

可以通过     java -XX:+PrintFlagsFinal -version | grep UseCompressedOops    命令来查看 JVM 是否开启了压
缩指针。


                                            No. 24 / 95
                                ⾯渣逆袭 JVM篇第⼆版-让天下所有的⾯渣都能逆袭

如果压缩指针开启，输出结果中的 bool UseCompressedOops 值为 true。

实例数据了解吗？                                                                                          

了解⼀些。

实例数据是对象实际的字段值，也就是成员变量的值，按照字段在类中声明的顺序存储。

  class ObjectDemo {
      int age;
      String name;
  }

JVM 会对这些数据进⾏对⻬/重排，以提⾼内存访问速度。

对⻬填充了解吗？                                                                                          

由于 JVM 的内存模型要求对象的起始地址是 8 字节对⻬（64 位 JVM 中），因此对象的总⼤⼩必须是 8 字节的倍
数。

如果对象头和实例数据的总⻓度不是 8 的倍数，JVM 会通过填充额外的字节来对⻬。

⽐如说，如果对象头 + 实例数据 = 14 字节，则需要填充 2 个字节，使总⻓度变为 16 字节。

为什么⾮要进⾏ 8 字节对⻬呢？                                                                                  

因为 CPU 进⾏内存访问时，⼀次寻址的指针⼤⼩是 8 字节，正好是 L1 缓存⾏的⼤⼩。如果不进⾏内存对⻬，则可
能出现跨缓存⾏访问，导致额外的缓存⾏加载，CPU 的访问效率就会降低。


⽐如说上图中 obj1 占 6 个字节，由于没有对⻬，导致这⼀⾏缓存中多了 2 个字节 obj2 的数据，当 CPU 访问 obj2 
的时候，就会导致缓存⾏刷新。

也就说，8 字节对⻬，是为了效率的提⾼，以空间换时间的⼀种⽅案。


                                             No. 25 / 95
                                ⾯渣逆袭 JVM篇第⼆版-让天下所有的⾯渣都能逆袭


new Object() 对象的内存⼤⼩是多少？                                                                          

推荐阅读：⾼端⾯试必备：⼀个 Java 对象占⽤多⼤内存 

⼀般来说，⽬前的操作系统都是 64 位的，并且 JDK 8 中的压缩指针是默认开启的，因此在 64 位的 JVM 上，                                 new 
Object() 的⼤⼩是 16 字节（12 字节的对象头 + 4 字节的对⻬填充）。


对象头的⼤⼩是固定的，在 32 位 JVM 上是 8 字节，在 64 位 JVM 上是 16 字节；如果开启了压缩指针，就是 12 
字节。

实例数据的⼤⼩取决于对象的成员变量和它们的类型。对于                         new Object() 来说，由于默认没有成员变量，因此我
们可以认为此时的实例数据⼤⼩是 0。


                                             No. 26 / 95
                                   ⾯渣逆袭 JVM篇第⼆版-让天下所有的⾯渣都能逆袭

假如 MyObject 对象有三个成员变量，分别是 int、long 和 byte 类型，那么它们占⽤的内存⼤⼩分别是 4 字节、8 
字节和 1 字节。

  class MyObject {
      int a;        // 4 字节
      long b;       // 8 字节
      byte c;       // 1 字节
  }

考虑到对⻬填充，MyObject 对象的总⼤⼩为 12（对象头） + 4（a） + 8（b） + 1（c） + 7（填充） = 32 字节。

⽤过 JOL 查看对象的内存布局吗？                                                                                            

⽤过。

JOL 是⼀款分析 JVM 对象布局的⼯具。

第⼀步，在 pom.xml 中引⼊ JOL 依赖：

  <dependency>
      <groupId>org.openjdk.jol</groupId>
      <artifactId>jol-core</artifactId>
      <version>0.9</version>
  </dependency>

第⼆步，使⽤ JOL 编写代码示例：

  public class JOLSample {
      public static void main(String[] args) {
          // 打印JVM详细信息（可选）
          System.out.println(VM.current().details());

          // 创建Object实例
          Object obj = new Object();

          // 打印Object实例的内存布局
          String layout = ClassLayout.parseInstance(obj).toPrintable();
          System.out.println(layout);
      }
  }

第三步，运⾏代码，查看输出结果：


                                                  No. 27 / 95
                                ⾯渣逆袭 JVM篇第⼆版-让天下所有的⾯渣都能逆袭


可以看到有 OFFSET、SIZE、TYPE DESCRIPTION、VALUE 这⼏个信息。

     OFFSET：偏移地址，单位字节；

     SIZE：占⽤的内存⼤⼩，单位字节；

     TYPE DESCRIPTION：类型描述，其中 object header 为对象头；

     VALUE：对应内存中当前存储的值，⼆进制 32 位；

从上⾯的结果能看到，对象头是 12 个字节，还有 4 个字节的 padding，                      new Object()  ⼀共 16 个字节。

对象的引⽤⼤⼩了解吗？                                                                                       

推荐阅读：Object o = new Object()占多少个字节？

在 64 位 JVM 上，未开启压缩指针时，对象引⽤占⽤ 8 字节；开启压缩指针时，对象引⽤会被压缩到 4 字节。
HotSpot 虚拟机默认是开启压缩指针的。


                                             No. 28 / 95
                                   ⾯渣逆袭 JVM篇第⼆版-让天下所有的⾯渣都能逆袭


我们来验证⼀下：

  class ReferenceSizeExample {
      private static class ReferenceHolder {
          Object reference;
      }

      public static void main(String[] args) {
          System.out.println(VM.current().details());
          System.out.println(ClassLayout.parseClass(ReferenceHolder.class).toPrintable());
      }
  }

运⾏代码，查看输出结果：


                                                  No. 29 / 95
                                ⾯渣逆袭 JVM篇第⼆版-让天下所有的⾯渣都能逆袭


ReferenceHolder.reference 的⼤⼩为 4 字节。

     1. Java ⾯试指南（付费）收录的帆软同学 3 Java 后端⼀⾯的原题：Object a = new object()的⼤⼩，对象
        引⽤占多少⼤⼩？

     2. Java ⾯试指南（付费）收录的去哪⼉⾯经同学 1 技术⼆⾯⾯试原题：Object 底层的数据结构（蒙了）

memo：2025 年 1 ⽉ 11 ⽇修改到此

10.JVM 怎么访问对象的？                                                                                   

主流的⽅式有两种：句柄和直接指针。

两种⽅式的区别在于，句柄是通过⼀个中间的句柄表来定位对象的，⽽直接指针则是通过引⽤直接指向对象的内存
地址。

优点是，对象被移动时只需要修改句柄表中的指针，⽽不需要修改对象引⽤本身。


                                            No. 30 / 95
                                ⾯渣逆袭 JVM篇第⼆版-让天下所有的⾯渣都能逆袭


在直接指针访问中，引⽤直接存储对象的内存地址；对象的实例数据和类型信息都存储在堆中固定的内存区域。

优点是访问速度更快，因为少了⼀次句柄的寻址操作。缺点是如果对象在内存中移动，引⽤需要更新为新的地址。


HotSpot 虚拟机主要使⽤直接指针来进⾏对象访问。

11.说⼀下对象有哪⼏种引⽤？                                                                                   

四种，分别是强引⽤、软引⽤、弱引⽤和虚引⽤。


                                             No. 31 / 95
                                ⾯渣逆袭 JVM篇第⼆版-让天下所有的⾯渣都能逆袭


强引⽤是 Java 中最常⻅的引⽤类型。使⽤ new 关键字赋值的引⽤就是强引⽤，只要强引⽤关联着对象，垃圾收集
器就不会回收这部分对象，即使内存不⾜。

  // str 就是⼀个强引⽤
  String str = new String("沉默王⼆");

软引⽤于描述⼀些⾮必须对象，通过 SoftReference 类实现。软引⽤的对象在内存不⾜时会被回收。

  // softRef 就是⼀个软引⽤
  SoftReference<String> softRef = new SoftReference<>(new String("沉默王⼆"));

弱引⽤⽤于描述⼀些短⽣命周期的⾮必须对象，如 ThreadLocal 中的 Entry，就是通过 WeakReference 类实现
的。弱引⽤的对象会在下⼀次垃圾回收时会被回收，不论内存是否充⾜。


                                             No. 32 / 95
                                ⾯渣逆袭 JVM篇第⼆版-让天下所有的⾯渣都能逆袭


  static class Entry extends WeakReference<ThreadLocal<?>> {
      /** The value associated with this ThreadLocal. */
      Object value;

      //节点类
      Entry(ThreadLocal<?> k, Object v) {
          //key赋值
          super(k);
          //value赋值
          value = v;
      }
  }

虚引⽤主要⽤来跟踪对象被垃圾回收的过程，通过 PhantomReference 类实现。虚引⽤的对象在任何时候都可能
被回收。

  // phantomRef 就是⼀个虚引⽤
  PhantomReference<String> phantomRef = new PhantomReference<>(new String("沉默王⼆"), new 
  ReferenceQueue<>());

     1. Java ⾯试指南（付费）收录的京东同学 4 云实习⾯试原题：四个引⽤(强软弱虚)

12.Java 堆的内存分区了解吗？                                                                                

了解。Java 堆被划分为新⽣代和⽼年代两个区域。


新⽣代⼜被划分为 Eden 空间和两个 Survivor 空间（From 和 To）。

新创建的对象会被分配到 Eden 空间。当 Eden 区填满时，会触发⼀次 Minor GC，清除不再使⽤的对象。存活下
来的对象会从 Eden 区移动到 Survivor 区。

对象在新⽣代中经历多次 GC 后，如果仍然存活，会被移动到⽼年代。当⽼年代内存不⾜时，会触发 Major GC，
对整个堆进⾏垃圾回收。

     1. Java ⾯试指南（付费）收录的得物⾯经同学 8 ⼀⾯⾯试原题：Java 中堆内存怎么组织的

     2. Java ⾯试指南（付费）收录的腾讯⾯经同学 27 云后台技术⼀⾯⾯试原题：怎么来区分对象是属于哪个
        代的？


                                            No. 33 / 95
                                ⾯渣逆袭 JVM篇第⼆版-让天下所有的⾯渣都能逆袭

13.说⼀下新⽣代的区域划分？                                                                                   

新⽣代的垃圾收集主要采⽤标记-复制算法，因为新⽣代的存活对象⽐较少，每次复制少量的存活对象效率⽐较
⾼。

基于这种算法，虚拟机将内存分为⼀块较⼤的 Eden 空间和两块较⼩的 Survivor 空间，每次分配内存只使⽤ Eden 
和其中⼀块 Survivor。发⽣垃圾收集时，将 Eden 和 Survivor 中仍然存活的对象⼀次性复制到另外⼀块 Survivor 
空间上，然后直接清理掉 Eden 和已⽤过的那块 Survivor 空间。默认 Eden 和 Survivor 的⼤⼩⽐例是 8∶1。


14.     对象什么时候会进⼊⽼年代？                                                                             

对象通常会在年轻代中分配，随着时间的推移和垃圾收集的进程，某些满⾜条件的对象会进⼊到⽼年代中，如⻓期
存活的对象。


⻓期存活的对象如何判断？                                                                                      

JVM 会为对象维护⼀个“年龄”计数器，记录对象在新⽣代中经历 Minor GC 的次数。每次 GC 未被回收的对象，其
年龄会加 1。

当超过⼀个特定阈值，默认值是 15，就会被认为⽼对象了，需要重点关照。这个年龄阈值可以通过 JVM 参数                                        -
XX:MaxTenuringThreshold  来设置。

                                            No. 34 / 95
                                ⾯渣逆袭 JVM篇第⼆版-让天下所有的⾯渣都能逆袭

可以通过     jinfo -flag MaxTenuringThreshold $(jps | grep -i nacos | awk '{print $1}')    来查看当前 
JVM 的年龄阈值。


  1. 如果应⽤中的对象存活时间较短，可以适当调⼤这个值，让对象在新⽣代多待⼀会⼉

  2. 如果对象存活时间较⻓，可以适当调⼩这个值，让对象更快进⼊⽼年代，减少在新⽣代的复制次数

⼤对象如何判断？                                                                                          

⼤对象是指占⽤内存较⼤的对象，如⼤数组、⻓字符串等。

  int[] array = new int[1000000];
  String str = new String(new char[1000000]);

其⼤⼩由 JVM 参数      -XX:PretenureSizeThreshold   控制，但在 JDK 8 中，默认值为 0，也就是说默认情况下，对
象仅根据 GC 存活的次数来判断是否进⼊⽼年代。


G1 垃圾收集器中，⼤对象会直接分配到 HUMONGOUS 区域。当对象⼤⼩超过⼀个 Region 容量的 50% 时，会被
认为是⼤对象。


Region 的⼤⼩可以通过 JVM 参数         -XX:G1HeapRegionSize  来设置，默认情况下从 1MB 到 32MB 不等，会根据
堆内存⼤⼩动态调整。

可以通过     java -XX:+UseG1GC -XX:+PrintGCDetails -version   查看 G1 垃圾收集器的相关信息。


                                             No. 35 / 95
                                ⾯渣逆袭 JVM篇第⼆版-让天下所有的⾯渣都能逆袭


从结果上来看，我本机上 G1 的堆⼤⼩为 2GB，Region 的⼤⼩为 4MB。

动态年龄判定了解吗？                                                                                        

如果 Survivor 区中所有对象的总⼤⼩超过了⼀定⽐例，通常是 Survivor 区的⼀半，那么年龄较⼩的对象也可能会
被提前晋升到⽼年代。

这是因为如果年龄较⼩的对象在 Survivor 区中占⽤了较⼤的空间，会导致 Survivor 区中的对象复制次数增多，影
响垃圾回收的效率。

     1. Java ⾯试指南（付费）收录的阿⾥⾯经同学 5 阿⾥妈妈 Java 后端技术⼀⾯⾯试原题：哪些情况下对象
        会进⼊⽼年代？

     2. Java ⾯试指南（付费）收录的京东⾯经同学 7 Java 后端技术⼀⾯⾯试原题：新⽣代对象转移到⽼年代
        的条件

     3. Java ⾯试指南（付费）收录的拼多多⾯经同学 4 技术⼀⾯⾯试原题：对象什么时候进⼊⽼年代

memo：2025 年 1 ⽉ 13 ⽇修改到此

15.STW 了解吗？                                                                                       

了解。

JVM 进⾏垃圾回收的过程中，会涉及到对象的移动，为了保证对象引⽤在移动过程中不被修改，必须暂停所有的⽤
户线程，像这样的停顿，我们称之为                Stop The World 。简称 STW。

如何暂停线程呢？                                                                                          

JVM 会使⽤⼀个名为安全点（Safe Point）的机制来确保线程能够被安全地暂停，其过程包括四个步骤：

     JVM 发出暂停信号；

     线程执⾏到安全点后，挂起⾃身并等待垃圾收集完成；

     垃圾回收器完成 GC 操作；

     线程恢复执⾏。

什么是安全点？                                                                                           

安全点是 JVM 的⼀种机制，常⽤于垃圾回收的 STW 操作，⽤于让线程在执⾏到某些特定位置时，可以被安全地暂
停。

通常位于⽅法调⽤、循环跳转、异常处理等位置，以保证线程暂停时数据的⼀致性。


                                            No. 36 / 95
                                ⾯渣逆袭 JVM篇第⼆版-让天下所有的⾯渣都能逆袭

⽤个通俗的⽐喻，⽼王去拉⻋，⻋上的东⻄很重，⽼王累的汗流浃背，但是⽼王不能在上坡或者下坡时休息，只能
在平地上停下来擦擦汗，喝⼝⽔。


推荐⼤家看看这个HotSpot JVM Deep Dive - Safepoint，对 safe point 有⼀个⽐较深⼊地解释。


16.对象⼀定分配在堆中吗？                                                                                    

不⼀定。 

默认情况下，Java 对象是在堆中分配的，但 JVM 会进⾏逃逸分析，来判断对象的⽣命周期是否只在⽅法内部，如
果是的话，这个对象可以在栈上分配。

举例来说，下⾯的代码中，对象              new Person()  的⽣命周期只在       testStackAllocation  ⽅法内部，因此 JVM 会
将这个对象分配在栈上。

                                             No. 37 / 95
                                   ⾯渣逆袭 JVM篇第⼆版-让天下所有的⾯渣都能逆袭


  public void testStackAllocation() {
      Person p = new Person();  // 对象可能分配在栈上
      p.name = "沉默王⼆是只狗";
      p.age = 18;
      System.out.println(p.name);
  }

什么是逃逸分析？                                                                                                      

逃逸分析是⼀种 JVM 优化技术，⽤来分析对象的作⽤域和⽣命周期，判断对象是否逃逸出⽅法或线程。

可以通过分析对象的引⽤流向，判断对象是否被⽅法返回、赋值到全局变量、传递到其他线程等，来确定对象是否
逃逸。

如果对象没有逃逸，就可以进⾏栈上分配、同步消除、标量替换等优化，以提⾼程序的性能。

可以通过      java -XX:+PrintFlagsFinal -version | grep DoEscapeAnalysis           来确认 JVM 是否开启了逃逸分
析。


逃逸具体是指什么？                                                                                                     

根据对象逃逸的范围，可以分为⽅法逃逸和线程逃逸。

当对象被⽅法外部的代码引⽤，⽣命周期超出了⽅法的范围，那么对象就必须分配在堆中，由垃圾收集器管理。

  public Person createPerson() {
      return new Person(); // 对象逃逸出⽅法
  }

⽐如说     new Person()   创建的对象被返回，那么这个对象就逃逸出当前⽅法了。


                                                  No. 38 / 95
                                ⾯渣逆袭 JVM篇第⼆版-让天下所有的⾯渣都能逆袭


再⽐如说，对象被另外⼀个线程引⽤，⽣命周期超出了当前线程，那么对象就必须分配在堆中，并且线程之间需要
同步。

  public void threadEscapeExample() {
      Person p = new Person(); // 对象逃逸到另⼀个线程
      new Thread(() -> {
          System.out.println(p);
      }).start();
  }

对象   new Person()  被另外⼀个线程引⽤了，发⽣了线程逃逸。

逃逸分析会带来什么好处？                                                                                      

主要有三个。

第⼀，如果确定⼀个对象不会逃逸，那么就可以考虑栈上分配，对象占⽤的内存随着栈帧出栈后销毁，这样⼀来，
垃圾收集的压⼒就降低很多。

第⼆，线程同步需要加锁，加锁就要占⽤系统资源，如果逃逸分析能够确定⼀个对象不会逃逸出线程，那么这个对
象就不⽤加锁，从⽽减少线程同步的开销。

                                            No. 39 / 95
                                   ⾯渣逆袭 JVM篇第⼆版-让天下所有的⾯渣都能逆袭

第三，如果对象的字段在⽅法中独⽴使⽤，JVM 可以将对象分解为标量变量，避免对象分配。

  public void scalarReplacementExample() {
      Point p = new Point(1, 2);
      System.out.println(p.getX() + p.getY());
  }

如果 Point 对象未逃逸，JVM 可以优化为：

  int x = 1;
  int y = 2;
  System.out.println(x + y);

     1. Java ⾯试指南（付费）收录的收钱吧⾯经同学 1 Java 后端⼀⾯⾯试原题：所有对象都在堆上对不对？

17.内存溢出和内存泄漏了解吗？                                                                                              

内存溢出，俗称 OOM，是指当程序请求分配内存时，由于没有⾜够的内存空间，从⽽抛出 OutOfMemoryError。

  List<String> list = new ArrayList<>();
  while (true) {
      list.add("OutOfMemory".repeat(1000)); // ⽆限增加内存
  }

可能是因为堆、元空间、栈或直接内存不⾜导致的。可以通过优化内存配置、减少对象分配来解决。

内存泄漏是指程序在使⽤完内存后，未能及时释放，导致占⽤的内存⽆法再被使⽤。随着时间的推移，内存泄漏会
导致可⽤内存逐渐减少，最终导致内存溢出。

内存泄漏通常是因为⻓期存活的对象持有短期存活对象的引⽤，⼜没有及时释放，从⽽导致短期存活对象⽆法被回
收⽽导致的。

  class MemoryLeakExample {
      private static List<Object> staticList = new ArrayList<>();
      public void addObject() {
          staticList.add(new Object()); // 对象不会被回收
      }
  }

⽤⼀个⽐较有味道的⽐喻来形容就是，内存溢出是排队去蹲坑，发现没坑了；内存泄漏，就是有⼈占着茅坑不拉
屎，导致坑位不够⽤。


                                                  No. 40 / 95
                                   ⾯渣逆袭 JVM篇第⼆版-让天下所有的⾯渣都能逆袭


     1. Java ⾯试指南（付费）收录的京东⾯经同学 1 Java 技术⼀⾯⾯试原题：说说 OOM 的原因

     2. Java ⾯试指南（付费）收录的快⼿⾯经同学 1 部⻔主站技术部⾯试原题：了解 OOM 吗？

18.能⼿写内存溢出的例⼦吗？                                                                                               

可以。

我就拿最常⻅的堆内存溢出来完成吧，堆内存溢出通常是因为创建了⼤量的对象，且⻓时间⽆法被垃圾收集器回
收，导致的。

  class HeapSpaceErrorGenerator {
      public static void main(String[] args) {
          // 第⼀步，创建⼀个⼤的容器
          List<byte[]> bigObjects = new ArrayList<>();
          try {
              // 第⼆步，循环写⼊数据
              while (true) {
                  // 第三步，创建⼀个⼤对象，⼀个⼤约 10M 的数组
                  byte[] bigObject = new byte[10 * 1024 * 1024];
                  // 第四步，将⼤对象添加到容器中
                  bigObjects.add(bigObject);
              }
          } catch (OutOfMemoryError e) {
              System.out.println("OutOfMemoryError 发⽣在 " + bigObjects.size() + " 对象后");
              throw e;
          }
      }
  }

很快就会发⽣内存溢出。

这就相当于⼀个房⼦⾥，不断堆积不能被回收的杂物，那么房⼦很快就会被堆满了。

也可以通过 VM 参数设置堆内存⼤⼩为                   -Xmx128M  ，然后运⾏程序，出现的内存溢出的时间会更快。


                                                  No. 41 / 95
                                ⾯渣逆袭 JVM篇第⼆版-让天下所有的⾯渣都能逆袭


可以看到，堆内存溢出发⽣在 11 个对象后。


     1. Java ⾯试指南（付费）收录的京东⾯经同学 1 Java 技术⼀⾯⾯试原题：说说 OOM 的原因

     2. Java ⾯试指南（付费）收录的快⼿⾯经同学 1 部⻔主站技术部⾯试原题：Java 哪些内存区域会发⽣ 
        OOM？为什么？

memo：2025 年 1 ⽉ 14 ⽇修改到此

19.内存泄漏可能由哪些原因导致呢？                                                                                

⽐如说：

①、静态的集合中添加的对象越来越多，但却没有及时清理；静态变量的⽣命周期与应⽤程序相同，如果静态变量
持有对象的引⽤，这些对象将⽆法被 GC 回收。


                                            No. 42 / 95
                                   ⾯渣逆袭 JVM篇第⼆版-让天下所有的⾯渣都能逆袭


  class OOM {
   static List list = new ArrayList();

   public void oomTests(){
     Object obj = new Object();

     list.add(obj);
    }
  }

②、单例模式下对象持有的外部引⽤⽆法及时释放；单例对象在整个应⽤程序的⽣命周期中存活，如果单例对象持
有其他对象的引⽤，这些对象将⽆法被回收。

  class Singleton {
      private static final Singleton INSTANCE = new Singleton();
      private List<Object> objects = new ArrayList<>();

      public static Singleton getInstance() {
          return INSTANCE;
      }
  }

③、数据库、IO、Socket 等连接资源没有及时关闭；

  try {
      Connection conn = null;
      Class.forName("com.mysql.jdbc.Driver");
      conn = DriverManager.getConnection("url", "", "");
      Statement stmt = conn.createStatement();
      ResultSet rs = stmt.executeQuery("....");
    } catch (Exception e) {

    }finally {
      //不关闭连接
    }

④、       ThreadLocal 的引⽤未被清理，线程退出后仍然持有对象引⽤；在线程执⾏完后，要调⽤ ThreadLocal 
的 remove ⽅法进⾏清理。

  ThreadLocal<Object> threadLocal = new ThreadLocal<>();
  threadLocal.set(new Object()); // 未清理

20.有没有处理过内存泄漏问题？                                                                                              

推荐阅读：

  1. ⼀次内存溢出的排查优化实战

  2. JVM 性能监控⼯具之命令⾏篇


                                                  No. 43 / 95
                                ⾯渣逆袭 JVM篇第⼆版-让天下所有的⾯渣都能逆袭

  3. JVM 性能监控⼯具之可视化篇

有。

当时在做技术派项⽬的时候，由于 ThreadLocal 没有及时清理导致出现了内存泄漏问题。

我⽤可视化的监控⼯具 VisualVM，配合 JDK ⾃带的 jstack 等命令⾏⼯具进⾏了排查。

⼤致的过程我回想了⼀下，主要有 7 个步骤：

第⼀步，使⽤       jps -l  查看运⾏的 Java 进程 ID。


第⼆步，使⽤      top -p [pid]  查看进程使⽤ CPU 和内存占⽤情况。


第三步，使⽤       top -Hp [pid]  查看进程下的所有线程占⽤ CPU 和内存情况。


                                            No. 44 / 95
                                ⾯渣逆袭 JVM篇第⼆版-让天下所有的⾯渣都能逆袭


第四步，抓取线程栈：          jstack -F 29452 > 29452.txt ，可以多抓⼏次做个对⽐。

   29452 为 pid，顺带作为⽂件名。


看看有没有线程死锁、死循环或⻓时间等待这些问题。


                                            No. 45 / 95
                                ⾯渣逆袭 JVM篇第⼆版-让天下所有的⾯渣都能逆袭


第五步，可以使⽤        jstat -gcutil [pid] 5000 10   每隔 5 秒输出 GC 信息，输出 10 次，查看 YGC 和 Full GC 
次数。


通常会出现 YGC 不增加或增加缓慢，⽽ Full GC 增加很快。

或使⽤    jstat -gccause [pid] 5000  输出 GC 摘要信息。


或使⽤    jmap -heap [pid]  查看堆的摘要信息，关注⽼年代内存使⽤是否达到阀值，若达到阀值就会执⾏ Full 
GC。


                                            No. 46 / 95
                                ⾯渣逆袭 JVM篇第⼆版-让天下所有的⾯渣都能逆袭


如果发现     Full GC  次数太多，就很⼤概率存在内存泄漏了。

第六步，⽣成       dump  ⽂件，然后借助可视化⼯具分析哪个对象⾮常多，基本就能定位到问题根源了。

执⾏命令     jmap -dump:format=b,file=heap.hprof 10025   会输出进程 10025 的堆快照信息，保存到⽂件 
heap.hprof 中。


                                             No. 47 / 95
                                ⾯渣逆袭 JVM篇第⼆版-让天下所有的⾯渣都能逆袭


第七步，使⽤图形化⼯具分析，如 JDK ⾃带的 VisualVM，从菜单 > ⽂件 > 装⼊ dump ⽂件。


然后在结果观察内存占⽤最多的对象，找到内存泄漏的源头。

     1. Java ⾯试指南（付费）收录的京东同学 10 后端实习⼀⾯的原题：什么是内存泄露

     2. Java ⾯试指南（付费）收录的快⼿⾯经同学 1 部⻔主站技术部⾯试原题：Java 哪些内存区域会发⽣ 
        OOM？为什么？

     3. Java ⾯试指南（付费）收录的美团⾯经同学 4 ⼀⾯⾯试原题：内存泄漏怎么排查

21.有没有处理过内存溢出问题？                                                                                  

有。

当时在做技术派的时候，由于上传的⽂件过⼤，没有正确处理，导致⼀下⼦撑爆了内存，程序直接崩溃了。

我记得是通过导出堆转储⽂件进⾏分析发现的。

第⼀步，使⽤ jmap 命令⼿动⽣成 Heap Dump ⽂件：

                                            No. 48 / 95
                                ⾯渣逆袭 JVM篇第⼆版-让天下所有的⾯渣都能逆袭


  jmap -dump:format=b,file=heap.hprof <pid>

然后使⽤ MAT、JProfiler 等⼯具进⾏分析，查看内存中的对象占⽤情况。

⼀般来说：

如果⽣产环境的内存还有很多空余，可以适当增⼤堆内存⼤⼩来解决，例如                                -Xmx4g  参数。

或者检查代码中是否存在内存泄漏，如未关闭的资源、⻓⽣命周期的对象等。

之后，在本地进⾏压⼒测试，模拟⾼负载情况下的内存表现，确保修改有效，且没有引⼊新的问题。

     1. Java ⾯试指南（付费）收录的华为⾯经同学 9 Java 通⽤软件开发⼀⾯⾯试原题：如何排查 OOM？

     2. Java ⾯试指南（付费）收录的荣耀⾯经同学 4 ⾯试原题：有没遇到内存泄露，溢出的情况，怎么发⽣和
        处理的？

22.什么情况下会发⽣栈溢出？（补充）                                                                               

   2024 年 10 ⽉ 16 ⽇增补

栈溢出发⽣在程序调⽤栈的深度超过 JVM 允许的最⼤深度时。

栈溢出的本质是因为线程的栈空间不⾜，导致⽆法再为新的栈帧分配内存。


当⼀个⽅法被调⽤时，JVM 会在栈中分配⼀个栈帧，⽤于存储该⽅法的执⾏信息。如果⽅法调⽤嵌套太深，栈帧不
断压⼊栈中，最终会导致栈空间耗尽，抛出 StackOverflowError。

最常⻅的栈溢出场景就是递归调⽤，尤其是没有正确的终⽌条件下，会导致递归⽆限进⾏。


                                            No. 49 / 95
                                   ⾯渣逆袭 JVM篇第⼆版-让天下所有的⾯渣都能逆袭


  class StackOverflowExample {
      public static void recursiveMethod() {
          // 没有终⽌条件的递归调⽤
          recursiveMethod();
      }

      public static void main(String[] args) {
          recursiveMethod();  // 导致栈溢出
      }
  }

另外，如果⽅法中定义了特别⼤的局部变量，栈帧会变得很⼤，导致栈空间更容易耗尽。

  public class LargeLocalVariables {
      public static void method() {
          int[] largeArray = new int[1000000];  // ⼤量局部变量
          method();  // 递归调⽤
      }

      public static void main(String[] args) {
          method();  // 导致栈溢出
      }
  }

     1. Java ⾯试指南（付费）收录的 OPPO ⾯经同学 1 ⾯试原题：什么情况下会发⽣栈溢出？
三、垃圾收集                                                                                                        

23.      讲讲 JVM 的垃圾回收机制（补充）                                                                                   

   本题是增补的内容，by 2024 年 03 ⽉ 09 ⽇；参照：深⼊理解 JVM 的垃圾回收机制

垃圾回收就是对内存堆中已经死亡的或者⻓时间没有使⽤的对象进⾏清除或回收。

JVM 在做 GC 之前，会先搞清楚什么是垃圾，什么不是垃圾，通常会通过可达性分析算法来判断对象是否存活。


                                                  No. 50 / 95
                                ⾯渣逆袭 JVM篇第⼆版-让天下所有的⾯渣都能逆袭


在确定了哪些垃圾可以被回收后，垃圾收集器（如 CMS、G1、ZGC）要做的事情就是进⾏垃圾回收，可以采⽤标
记清除算法、复制算法、标记整理算法、分代收集算法等。

技术派项⽬使⽤的 JDK 8，采⽤的是 CMS 垃圾收集器。

  java -XX:+UseConcMarkSweepGC \
       -XX:+UseParNewGC \
       -XX:CMSInitiatingOccupancyFraction=75 \
       -XX:+UseCMSInitiatingOccupancyOnly \
       -jar your-application.jar

垃圾回收的过程是什么？                                                                                       

Java 的垃圾回收过程主要分为标记存活对象、清除⽆⽤对象、以及内存压缩/整理三个阶段。不同的垃圾回收器在
执⾏这些步骤时会采⽤不同的策略和算法。

     1. Java ⾯试指南（付费）收录的华为 OD 技术⼀⾯遇到的⼀道原题。

     2. Java ⾯试指南（付费）收录的美团⾯经同学 2 Java 后端技术⼀⾯⾯试原题：了解 GC 吗？不可达判断知
        道吗？

     3. Java ⾯试指南（付费）收录的腾讯⾯经同学 26 暑期实习微信⽀付⾯试原题：JVM 垃圾删除

     4. Java ⾯试指南（付费）收录的得物⾯经同学 8 ⼀⾯⾯试原题：Java 中垃圾回收的原理

     5. Java ⾯试指南（付费）收录的快⼿同学 2 ⼀⾯⾯试原题：JVM了解吗？内存回收机制说⼀下？

     6. Java ⾯试指南（付费）收录的 OPPO ⾯经同学 1 ⾯试原题：垃圾回收的过程是什么？

     7. Java ⾯试指南（付费）收录的vivo ⾯经同学 10 技术⼀⾯⾯试原题：说⼀下GC，有哪些⽅法


                                             No. 51 / 95
                                ⾯渣逆袭 JVM篇第⼆版-让天下所有的⾯渣都能逆袭

     8. Java ⾯试指南（付费）收录的荣耀⾯经同学 4 ⾯试原题：对垃圾回收的理解？

     9. Java ⾯试指南（付费）收录的字节跳动同学 17 后端技术⾯试原题：垃圾回收机制 为什么要学jvm 内存
        泄漏场景

    10. Java ⾯试指南（付费）收录的腾讯⾯经同学 27 云后台技术⼀⾯⾯试原题：GC？怎么样去识别垃圾？

    11. Java ⾯试指南（付费）收录的理想汽⻋⾯经同学 2 ⼀⾯⾯试原题：说说你对GC的了解？

    12. Java ⾯试指南（付费）收录的腾讯⾯经同学 29 Java 后端⼀⾯原题：JVM垃圾回收机制？

24.     如何判断对象仍然存活？                                                                               

Java 通过可达性分析算法来判断⼀个对象是否还存活。

通过⼀组名为 “GC Roots” 的根对象，进⾏递归扫描，⽆法从根对象到达的对象就是“垃圾”，可以被回收。


这也是 G1、CMS 等主流垃圾收集器使⽤的主要算法。

什么是引⽤计数法？                                                                                         

每个对象有⼀个引⽤计数器，记录引⽤它的次数。当计数器为零时，对象可以被回收。


                                             No. 52 / 95
                                ⾯渣逆袭 JVM篇第⼆版-让天下所有的⾯渣都能逆袭


引⽤计数法⽆法解决循环引⽤的问题。例如，两个对象互相引⽤，但不再被其他对象引⽤，它们的引⽤计数都不为
零，因此不会被回收。

做可达性分析的时候，应该有哪些前置性的操作？                                                                            

在进⾏垃圾回收之前，JVM 会暂停所有正在执⾏的应⽤线程。

这是因为可达性分析过程必须确保在执⾏分析时，内存中的对象关系不会被应⽤线程修改。如果不暂停应⽤线程，
可能会出现对象引⽤的改变，导致垃圾回收过程中判断对象是否可达的结果不⼀致，从⽽引发严重的内存错误或数
据丢失。

     1. Java ⾯试指南（付费）收录的京东⾯经同学 7 京东到家⾯试原题：如何判断⼀个对象是否可以回收

     2. Java ⾯试指南（付费）收录的快⼿同学 2 ⼀⾯⾯试原题：做可达性分析的时候，应该有哪些前置性的操
        作？

     3. Java ⾯试指南（付费）收录的京东⾯经同学 9 ⾯试原题：什么样的对象算作垃圾对象

     4. Java ⾯试指南（付费）收录的同学 D ⼩⽶⼀⾯原题：gc中判断对象可回收的⽅式有哪些

25.Java 中可作为 GC Roots 的引⽤有哪⼏种？                                                                    

  1. 推荐阅读：深⼊理解垃圾回收机制

  2. 推荐阅读：R ⼤的所谓“GC roots”

所谓的 GC Roots，就是⼀组必须活跃的引⽤，它们是程序运⾏时的起点，是⼀切引⽤链的源头。在 Java 中，GC 
Roots 包括以下⼏种：

     虚拟机栈中的引⽤（⽅法的参数、局部变量等）

     本地⽅法栈中 JNI 的引⽤

     类静态变量

     运⾏时常量池中的常量（String 或 Class 类型）


                                             No. 53 / 95
                                ⾯渣逆袭 JVM篇第⼆版-让天下所有的⾯渣都能逆袭


说说虚拟机栈中的引⽤？                                                                                       

来看下⾯这段代码：

  public class StackReference {
      public void greet() {
          Object localVar = new Object(); // 这⾥的 localVar 是⼀个局部变量，存在于虚拟机栈中
          System.out.println(localVar.toString());
      }

      public static void main(String[] args) {
          new StackReference().greet();
      }
  }

在 greet ⽅法中，localVar 是⼀个局部变量，存在于虚拟机栈中，可以被认为是 GC Roots。

在 greet ⽅法执⾏期间，localVar 引⽤的对象是活跃的，因为它是从 GC Roots 可达的。

当 greet ⽅法执⾏完毕后，localVar 的作⽤域结束，localVar 引⽤的 Object 对象不再由任何 GC Roots 引⽤（假设
没有其他引⽤指向这个对象），因此它将有资格作为垃圾被回收掉                              。

说说本地⽅法栈中 JNI 的引⽤？                                                                                 

Java 通过 JNI 提供了⼀种机制，允许 Java 代码调⽤本地代码（通常是 C 或 C++ 编写的代码）。

当调⽤ Java ⽅法时，虚拟机会创建⼀个栈帧并压⼊虚拟机栈，⽽当它调⽤本地⽅法时，虚拟机会通过动态链接直
接调⽤指定的本地⽅法。


                                            No. 54 / 95
                                   ⾯渣逆袭 JVM篇第⼆版-让天下所有的⾯渣都能逆袭


JNI 引⽤是在 Java 本地接⼝代码中创建的引⽤，这些引⽤可以指向 Java 堆中的对象。

  // 假设的JNI⽅法
  public native void nativeMethod();

  // 假设在C/C++中实现的本地⽅法
  /*
   * Class:     NativeExample
   * Method:    nativeMethod
   * Signature: ()V
   */
  JNIEXPORT void JNICALL Java_NativeExample_nativeMethod(JNIEnv *env, jobject thisObj) {
      jobject localRef = (*env)->NewObject(env, ...); // 在本地⽅法栈中创建JNI引⽤
      // localRef 引⽤的Java对象在本地⽅法执⾏期间是活跃的
  }

在本地代码中，localRef 是对 Java 对象的⼀个 JNI 引⽤，它在本地⽅法执⾏期间保持 Java 对象活跃，可以被认为
是 GC Roots。

⼀旦 JNI ⽅法执⾏完毕，除⾮这个引⽤是全局的，否则它指向的对象将会被作为垃圾回收掉（假设没有其他地⽅再
引⽤这个对象）。

说说类静态变量？                                                                                                      

来看下⾯这段代码：


                                                  No. 55 / 95
                                ⾯渣逆袭 JVM篇第⼆版-让天下所有的⾯渣都能逆袭


  public class StaticFieldReference {
      private static Object staticVar = new Object(); // 类静态变量

      public static void main(String[] args) {
          System.out.println(staticVar.toString());
      }
  }

StaticFieldReference 类中的 staticVar 引⽤了⼀个 Object 对象，这个引⽤存储在元空间，可以被认为是 GC 
Roots。

只要 StaticFieldReference 类未被卸载，staticVar 引⽤的对象都不会被垃圾回收。如果 StaticFieldReference 类被
卸载（这通常发⽣在其类加载器被垃圾回收时），那么 staticVar 引⽤的对象也将有资格被垃圾回收（如果没有其
他引⽤指向这个对象）。

说说运⾏时常量池中的常量？                                                                                     

来看这段代码：

  class ConstantPoolReference {
      public static final String CONSTANT_STRING = "Hello, World"; // 常量，存在于运⾏时常量池中
      public static final Class<?> CONSTANT_CLASS = Object.class; // 类类型常量

      public static void main(String[] args) {
          System.out.println(CONSTANT_STRING);
          System.out.println(CONSTANT_CLASS.getName());
      }
  }

在 ConstantPoolReference 中，CONSTANT_STRING 和 CONSTANT_CLASS 作为常量存储在运⾏时常量池。它们
可以⽤来作为 GC Roots。

这些常量引⽤的对象（字符串"Hello, World"和 Object.class 类对象）在常量池中，只要包含这些常量的 
ConstantPoolReference 类未被卸载，这些对象就不会被垃圾回收。

     1. Java ⾯试指南（付费）收录的帆软同学 3 Java 后端⼀⾯的原题：哪些对象可以作为 GC Roots

     2. Java ⾯试指南（付费）收录的腾讯⾯经同学 27 云后台技术⼀⾯⾯试原题：GC Root？

     3. Java ⾯试指南（付费）收录的同学 D ⼩⽶⼀⾯原题：那些对象可以作为gc root

26.finalize()⽅法了解吗？                                                                               

垃圾回收就是古代的秋后问斩，              finalize()  就是⼑下留⼈，在⼈犯被处决之前，还要做最后⼀次审计，⻘天⼤⽼
爷会看看有没有什么冤情，需不需要⼑下留⼈。


                                            No. 56 / 95
                                ⾯渣逆袭 JVM篇第⼆版-让天下所有的⾯渣都能逆袭


如果对象在进⾏可达性分析后发现没有与 GC Roots 相连接的引⽤链，那它将会被第⼀次标记，随后进⾏⼀次筛
选。

筛选的条件是对象是否有必要执⾏               finalize() ⽅法。

如果对象在      finalize()  中成功拯救⾃⼰——只要重新与引⽤链上的任何⼀个对象建⽴关联即可。

譬如把⾃⼰ （this 关键字）赋值给某个类变量或者对象的成员变量，那在第⼆次标记时它就”逃过⼀劫“；但是如果
没有抓住这个机会，那么对象就真的要被回收了。

27.     垃圾收集算法了解吗？                                                                                

垃圾收集算法主要有三种，分别是标记-清除算法、标记-复制算法和标记-整理算法。

说说标记-清除算法？                                                                                        

 标记-清除   算法分为两个阶段：

     标记：标记所有需要回收的对象

     清除：回收所有被标记的对象


                                             No. 57 / 95
                                ⾯渣逆袭 JVM篇第⼆版-让天下所有的⾯渣都能逆袭


优点是实现简单，缺点是回收过程中会产⽣内存碎⽚。

说说标记-复制算法？                                                                                        

 标记-复制   算法可以解决标记-清除算法的内存碎⽚问题，因为它将内存空间划分为两块，每次只使⽤其中⼀块。当
这⼀块的内存⽤完了，就将还存活着的对象复制到另外⼀块上⾯，然后清理掉这⼀块。


缺点是浪费了⼀半的内存空间。

说说标记-整理算法？                                                                                        


                                            No. 58 / 95
                                ⾯渣逆袭 JVM篇第⼆版-让天下所有的⾯渣都能逆袭

 标记-整理   算法是标记-清除复制算法的升级版，它不再划分内存空间，⽽是将存活的对象向内存的⼀端移动，然后
清理边界以外的内存。


缺点是移动对象的成本⽐较⾼。

说说分代收集算法？                                                                                         

 分代收集   算法是⽬前主流的垃圾收集算法，它根据对象存活周期的不同将内存划分为⼏块，⼀般分为新⽣代和⽼年
代。


新⽣代⽤复制算法，因为⼤部分对象⽣命周期短。⽼年代⽤标记-整理算法，因为对象存活率较⾼。

为什么要⽤分代收集呢？                                                                                       

分代收集算法的核⼼思想是根据对象的⽣命周期优化垃圾回收。


                                            No. 59 / 95
                                ⾯渣逆袭 JVM篇第⼆版-让天下所有的⾯渣都能逆袭

新⽣代的对象⽣命周期短，使⽤复制算法可以快速回收。⽼年代的对象⽣命周期⻓，使⽤标记-整理算法可以减少
移动对象的成本。

标记复制的标记过程和复制过程会不会停顿？                                                                              

在标记-复制算法 中，标记阶段和复制阶段都会触发STW。

     标记阶段停顿是为了保证对象的引⽤关系不被修改。

     复制阶段停顿是防⽌对象在复制过程中被修改。

     1. Java ⾯试指南（付费）收录的字节跳动⾯经同学 1 Java 后端技术⼀⾯⾯试原题：垃圾回收算法了解多
        少？

     2. Java ⾯试指南（付费）收录的⼩⽶⾯经同学 F ⾯试原题：垃圾回收的算法及详细介绍

     3. Java ⾯试指南（付费）收录的腾讯⾯经同学 27 云后台技术⼀⾯⾯试原题：回收的⽅法？分代收集算法
        ⾥⾯具体是怎么回收的？为什么要⽤分代收集呢？

     4. Java ⾯试指南（付费）收录的百度同学 4 ⾯试原题：Gc 算法有哪些?

     5. Java ⾯试指南（付费）收录的京东⾯经同学 9 ⾯试原题：问了垃圾回收算法，针对问了每个算法的优缺
        点

     6. Java ⾯试指南（付费）收录的同学 D ⼩⽶⼀⾯原题：gc垃圾回收算法有哪些

28.Minor GC、Major GC、Mixed GC、Full GC 都是什么意思？                                                     

Minor GC 也称为 Young GC，是指发⽣在年轻代的垃圾收集。年轻代包含 Eden 区以及两个 Survivor 区。


Major GC 也称为 Old GC，主要指的是发⽣在⽼年代的垃圾收集。是 CMS 的特有⾏为。

Mixed GC 是 G1 垃圾收集器特有的⼀种 GC 类型，它在⼀次 GC 中同时清理年轻代和部分⽼年代。

Full GC 是最彻底的垃圾收集，涉及整个 Java 堆和⽅法区。它是最耗时的 GC，通常在 JVM 压⼒很⼤时发⽣。

FULL gc怎么去清理的？                                                                                    

Full GC 会从 GC Root 出发，标记所有可达对象。新⽣代使⽤复制算法，清空 Eden 区。⽼年代使⽤标记-整理算
法，回收对象并消除碎⽚。


                                            No. 60 / 95
                                ⾯渣逆袭 JVM篇第⼆版-让天下所有的⾯渣都能逆袭

停顿时间较⻓，会影响系统响应性能。

     1. Java ⾯试指南（付费）收录的阿⾥⾯经同学 5 阿⾥妈妈 Java 后端技术⼀⾯⾯试原题：full gc 和 young 
        gc 的区别

     2. Java ⾯试指南（付费）收录的腾讯⾯经同学 27 云后台技术⼀⾯⾯试原题：FULL gc怎么去清理的？

29.Young GC 什么时候触发？                                                                               

如果 Eden 区没有⾜够的空间时，就会触发 Young GC 来清理新⽣代。

     1. Java ⾯试指南（付费）收录的百度同学 4 ⾯试原题：什么时候会触发 GC?

30.什么时候会触发 Full GC？                                                                               

在进⾏ Young GC 的时候，如果发现           ⽼年代可⽤的连续内存空间          < 新⽣代历次 Young GC 后升⼊⽼年代的对象总和的
平均⼤⼩    ，说明本次 Young GC 后升⼊⽼年代的对象⼤⼩，可能超过了⽼年代当前可⽤的内存空间，就会触发 Full 
GC。

执⾏ Young GC 后⽼年代没有⾜够的内存空间存放转⼊的对象，会⽴即触发⼀次 Full GC。

 System.gc() 、 jmap -dump  等命令会触发 full gc。

空间分配担保是什么？                                                                                        

空间分配担保是指在进⾏ Minor GC 前，JVM 会确保⽼年代有⾜够的空间存放从新⽣代晋升的对象。如果⽼年代空
间不⾜，可能会触发 Full GC。

     1. Java ⾯试指南（付费）收录的快⼿同学 4 ⼀⾯原题：如何判断死亡对象？GC Roots有哪些？空间分配
        担保是什么？

31.     知道哪些垃圾收集器？                                                                                

推荐阅读：深⼊理解 JVM 的垃圾收集器：CMS、G1、ZGC

JVM 的垃圾收集器主要分为两⼤类：分代收集器和分区收集器，分代收集器的代表是 CMS，分区收集器的代表是 
G1 和 ZGC。


                                             No. 61 / 95
                                ⾯渣逆袭 JVM篇第⼆版-让天下所有的⾯渣都能逆袭


CMS 是第⼀个关注 GC 停顿时间的垃圾收集器，JDK 1.5 时引⼊，JDK9 被标记弃⽤，JDK14 被移除。

G1 在 JDK 1.7 时引⼊，在 JDK 9 时取代 CMS 成为了默认的垃圾收集器。

ZGC 是 JDK11 推出的⼀款低延迟垃圾收集器，适⽤于⼤内存低延迟服务的内存管理和回收，在 128G 的⼤堆下，
最⼤停顿时间才 1.68 ms，性能远胜于 G1 和 CMS。

说说 Serial 收集器？                                                                                    

Serial 收集器是最基础、历史最悠久的收集器。

如同它的名字（串⾏），它是⼀个单线程⼯作的收集器，使⽤⼀个处理器或⼀条收集线程去完成垃圾收集⼯作。并
且进⾏垃圾收集时，必须暂停其他所有⼯作线程，直到垃圾收集结束——这就是所谓的“Stop The World”。

Serial/Serial Old 收集器的运⾏过程如图：


                                             No. 62 / 95
                                ⾯渣逆袭 JVM篇第⼆版-让天下所有的⾯渣都能逆袭

说说 ParNew 收集器？                                                                                    

ParNew 收集器实质上是 Serial 收集器的多线程并⾏版本，使⽤多条线程进⾏垃圾收集。

ParNew/Serial Old 收集器运⾏示意图如下：


说说 Parallel Scavenge 收集器？                                                                         

Parallel Scavenge 收集器是⼀款新⽣代收集器，基于标记-复制算法实现，也能够并⾏收集。和 ParNew 有些类
似，但 Parallel Scavenge 主要关注的是垃圾收集的吞吐量——所谓吞吐量，就是 CPU ⽤于运⾏⽤户代码的时间和
总消耗时间的⽐值，⽐值越⼤，说明垃圾收集的占⽐越⼩。


根据对象存活周期的不同会将内存划分为⼏块，⼀般是把 Java 堆分为新⽣代和⽼年代，这样就可以根据各个年代
的特点采⽤最适当的收集算法。

说说 Serial Old 收集器？                                                                                

Serial Old 是 Serial 收集器的⽼年代版本，它同样是⼀个单线程收集器，使⽤标记-整理算法。

说说 Parallel Old 收集器？                                                                              

Parallel Old 是 Parallel Scavenge 收集器的⽼年代版本，基于标记-整理算法实现，使⽤多条 GC 线程在 STW 期间
同时进⾏垃圾回收。


                                            No. 63 / 95
                                ⾯渣逆袭 JVM篇第⼆版-让天下所有的⾯渣都能逆袭


说说 CMS 收集器？                                                                                       

CMS 在 JDK 1.5 时引⼊，JDK 9 时被标记弃⽤，JDK 14 时被移除。

CMS 是⼀种低延迟的垃圾收集器，采⽤标记-清除算法，分为初始标记、并发标记、重新标记和并发清除四个阶
段，优点是垃圾回收线程和应⽤线程同时运⾏，停顿时间短，适合延迟敏感的应⽤，但容易产⽣内存碎⽚，可能触
发 Full GC。


说说 G1 收集器？                                                                                        

G1 在 JDK 1.7 时引⼊，在 JDK 9 时取代 CMS 成为默认的垃圾收集器。

G1 是⼀种⾯向⼤内存、⾼吞吐场景的垃圾收集器，它将堆划分为多个⼩的 Region，通过标记-整理算法，避免了
内存碎⽚问题。优点是停顿时间可控，适合⼤堆场景，但调优较复杂。


                                            No. 64 / 95
                                ⾯渣逆袭 JVM篇第⼆版-让天下所有的⾯渣都能逆袭


说说 ZGC 收集器？                                                                                       

ZGC 是 JDK 11 时引⼊的⼀款低延迟的垃圾收集器，最⼤特点是将垃圾收集的停顿时间控制在 10ms 以内，即使在 
TB 级别的堆内存下也能保持较低的停顿时间。

它通过并发标记和重定位来避免⼤部分 Stop-The-World 停顿，主要依赖指针染⾊来管理对象状态。


     标记对象的可达性：通过在指针上增加标记位，不需要额外的标记位即可判断对象的存活状态。

     重定位状态：在对象被移动时，可以通过指针染⾊来更新对象的引⽤，⽽不需要等待全局同步。

适⽤于需要超低延迟的场景，⽐如⾦融交易系统、电商平台。

垃圾回收器的作⽤是什么？                                                                                      

垃圾回收器的核⼼作⽤是⾃动管理 Java 应⽤程序的运⾏时内存。它负责识别哪些内存是不再被应⽤程序使⽤的，
并释放这些内存以便重新使⽤。

这⼀过程减少了程序员⼿动管理内存的负担，降低了内存泄漏和溢出错误的⻛险。

     1. Java ⾯试指南（付费）收录的滴滴同学 2 技术⼆⾯的原题：了解哪些垃圾回收器，只能回收⼀个代（新
        ⽣代、⽼年代）吗，使⽤的 jdk 版本

     2. Java ⾯试指南（付费）收录的京东同学 10 后端实习⼀⾯的原题：垃圾回收器的作⽤是什么

                                            No. 65 / 95
                                ⾯渣逆袭 JVM篇第⼆版-让天下所有的⾯渣都能逆袭

     3. Java ⾯试指南（付费）收录的携程⾯经同学 10 Java 暑期实习⼀⾯⾯试原题：有哪些垃圾回收器，选⼀
        个讲⼀下垃圾回收的流程

     4. Java ⾯试指南（付费）收录的京东同学 4 云实习⾯试原题：常⻅的 7 个 GC 回收器

     5. Java ⾯试指南（付费）收录的美团⾯经同学 15 点评后端技术⾯试原题：讲⼀下知道的垃圾回收器，问
        知不知道ZGC回收器（不知道）

     6. Java ⾯试指南（付费）收录的阿⾥云⾯经同学 22 ⾯经：cms和g1的区别

     7. Java ⾯试指南（付费）收录的京东⾯经同学 9 ⾯试原题：怎么理解并发和并⾏，Parallel Old和CMS有
        什么区别？

32.     能详细说⼀下 CMS 的垃圾收集过程吗？                                                                      


CMS 使⽤标记-清除算法进⾏垃圾收集，分 4 ⼤步：

     初始标记：标记所有从 GC Roots 直接可达的对象，这个阶段需要 STW，但速度很快。

     并发标记：从初始标记的对象出发，遍历所有对象，标记所有可达的对象。这个阶段是并发进⾏的。

     重新标记：完成剩余的标记⼯作，包括处理并发阶段遗留下来的少量变动，这个阶段通常需要短暂的 STW 停
     顿。

     并发清除：清除未被标记的对象，回收它们占⽤的内存空间。

你提到了remark，那它remark具体是怎么执⾏的？三⾊标记法？                                                                

是的，remark 阶段通常会结合三⾊标记法来执⾏，确保在并发标记期间所有存活对象都被正确标记。⽬的是修正
并发标记阶段中可能遗漏的对象引⽤变化。

在 remark 阶段，垃圾收集器会停⽌应⽤线程，以确保在这个阶段不会有引⽤关系的进⼀步变化。这种暂停通常很
短暂。remark 阶段主要包括以下操作：

  1. 处理写屏障记录的引⽤变化：在并发标记阶段，应⽤程序可能会更新对象的引⽤（⽐如⼀个⿊⾊对象新增了
     对⼀个⽩⾊对象的引⽤），这些变化通过写屏障记录下来。在 remark 阶段，GC 会处理这些记录，确保所有
     可达对象都正确地标记为灰⾊或⿊⾊。

  2. 扫描灰⾊对象：再次遍历灰⾊对象，处理它们的所有引⽤，确保引⽤的对象正确标记为灰⾊或⿊⾊。

  3. 清理：确保所有引⽤关系正确处理后，灰⾊对象标记为⿊⾊，⽩⾊对象保持不变。这⼀步完成后，所有存活
     对象都应当是⿊⾊的。


                                            No. 66 / 95
                                ⾯渣逆袭 JVM篇第⼆版-让天下所有的⾯渣都能逆袭

什么是三⾊标记法？                                                                                         


三⾊标记法⽤于标记对象的存活状态，它将对象分为三类：

  1. ⽩⾊（White）：尚未访问的对象。垃圾回收结束后，仍然为⽩⾊的对象会被认为是不可达的对象，可以回
     收。

  2. 灰⾊（Gray）：已经访问到但未标记完其引⽤的对象。灰⾊对象是需要进⼀步处理的。

  3. ⿊⾊（Black）：已经访问到并且其所有引⽤对象都已经标记过。⿊⾊对象是完全处理过的，不需要再处理。

三⾊标记法的⼯作流程：

①、初始标记（Initial Marking）：从 GC Roots 开始，标记所有直接可达的对象为灰⾊。

②、并发标记（Concurrent Marking）：在此阶段，标记所有灰⾊对象引⽤的对象为灰⾊，然后将灰⾊对象⾃身
标记为⿊⾊。这个过程是并发的，和应⽤线程同时进⾏。

此阶段的⼀个问题是，应⽤线程可能在并发标记期间修改对象的引⽤关系，导致⼀些对象的标记状态不准确。

③、重新标记（Remarking）：重新标记阶段的⽬标是处理并发标记阶段遗漏的引⽤变化。为了确保所有存活对象
都被正确标记，remark 需要在 STW 暂停期间执⾏。

④、使⽤写屏障（Write Barrier）来捕捉并发标记阶段应⽤线程对对象引⽤的更新。通过遍历这些更新的引⽤来修
正标记状态，确保遗漏的对象不会被错误地回收。

推荐阅读：⼩道哥的三⾊标记

     1. Java ⾯试指南（付费）收录的携程⾯经同学 10 Java 暑期实习⼀⾯⾯试原题：有哪些垃圾回收器，选⼀
        个讲⼀下垃圾回收的流程

     2. Java ⾯试指南（付费）收录的携程⾯经同学 1 Java 后端技术⼀⾯⾯试原题：对象创建到销毁，内存如
        何分配的，（类加载和对象创建过程，CMS，G1 内存清理和分配）

     3. Java ⾯试指南（付费）收录的收钱吧⾯经同学 1 Java 后端⼀⾯⾯试原题：CMS⽤了什么垃圾回收算
        法？你提到了remark，那它remark具体是怎么执⾏的？三⾊标记法？

     4. Java ⾯试指南（付费）收录的京东⾯经同学 9 ⾯试原题：问了CMS垃圾回收器

33.     G1 垃圾收集器了解吗？                                                                              

G1 在 JDK 1.7 时引⼊，在 JDK 9 时取代 CMS 成为默认的垃圾收集器。


                                             No. 67 / 95
                                ⾯渣逆袭 JVM篇第⼆版-让天下所有的⾯渣都能逆袭


G1 把 Java 堆划分为多个⼤⼩相等的独⽴区域Region，每个区域都可以扮演新⽣代或⽼年代的⻆⾊。

同时，G1 还有⼀个专⻔为⼤对象设计的 Region，叫 Humongous 区。

   ⼤对象的判定规则是，如果⼀个⼤对象超过了⼀个 Region ⼤⼩的 50%，⽐如每个 Region 是 2M，只要⼀个
   对象超过了 1M，就会被放⼊ Humongous 中。

这种区域化管理使得 G1 可以更灵活地进⾏垃圾收集，只回收部分区域⽽不是整个新⽣代或⽼年代。

G1 收集器的运⾏过程⼤致可划分为这⼏个步骤：

①、并发标记，G1 通过并发标记的⽅式找出堆中的垃圾对象。并发标记阶段与应⽤线程同时执⾏，不会导致应⽤
线程暂停。

②、混合收集，在并发标记完成后，G1 会计算出哪些区域的回收价值最⾼（也就是包含最多垃圾的区域），然后
优先回收这些区域。这种回收⽅式包括了部分新⽣代区域和⽼年代区域。

选择回收成本低⽽收益⾼的区域进⾏回收，可以提⾼回收效率和减少停顿时间。

③、可预测的停顿，G1 在垃圾回收期间仍然需要「Stop the World」。不过，G1 在停顿时间上添加了预测机制，
⽤户可以 JVM 启动时指定期望停顿时间，G1 会尽可能地在这个时间内完成垃圾回收。


     1. Java ⾯试指南（付费）收录的京东⾯经同学 1 Java 技术⼀⾯⾯试原题：说说 G1 垃圾回收器的原理


                                            No. 68 / 95
                                ⾯渣逆袭 JVM篇第⼆版-让天下所有的⾯渣都能逆袭

     2. Java ⾯试指南（付费）收录的携程⾯经同学 1 Java 后端技术⼀⾯⾯试原题：对象创建到销毁，内存如
        何分配的，（类加载和对象创建过程，CMS，G1 内存清理和分配）

     3. Java ⾯试指南（付费）收录的百度同学 4 ⾯试原题：G1 垃圾回收器了解吗?

     4. Java ⾯试指南（付费）收录的理想汽⻋⾯经同学 2 ⼀⾯⾯试原题：了解过G1垃圾回收器吗？

34.有了 CMS，为什么还要引⼊ G1？                                                                             

   特性                 CMS                                     G1

   设计⽬标               低停顿时间                                   可预测的停顿时间

   并发性                是                                       是

   内存碎⽚               是，容易产⽣碎⽚                                否，通过区域划分和压缩减少碎⽚

   收集代数               年轻代和⽼年代                                 整个堆，但区分年轻代和⽼年代

   并发阶段               并发标记、并发清理                               并发标记、并发清理、并发回收

   停顿时间预测             较难预测                                    可配置停顿时间⽬标

   容易出现的问题            内存碎⽚、Concurrent Mode Failure            较少出现⻓时间停顿

CMS 适⽤于对延迟敏感的应⽤场景，主要⽬标是减少停顿时间，但容易产⽣内存碎⽚。

G1 则提供了更好的停顿时间预测和内存压缩能⼒，适⽤于⼤内存和多核处理器环境。

     1. Java ⾯试指南（付费）收录的快⼿⾯经同学 5 ⾯试原题：CMS 垃圾收集器和 G1 垃圾收集器什么区别

35.你们线上⽤的什么垃圾收集器？                                                                                 

我们⽣产环境中采⽤了设计⽐较优秀的 G1 垃圾收集器，因为它不仅能满⾜低停顿的要求，⽽且解决了 CMS 的浮
动垃圾问题、内存碎⽚问题。

G1 ⾮常适合⼤内存、多核处理器的环境。

   以上是⽐较符合⾯试官预期的回答，但实际上，⼤多数情况下我们可能还是使⽤的 JDK 8 默认垃圾收集器。

可以通过以下命令查看当前 JVM 的垃圾收集器：

  java -XX:+PrintCommandLineFlags -version


                                            No. 69 / 95
                                ⾯渣逆袭 JVM篇第⼆版-让天下所有的⾯渣都能逆袭

 UseParallelGC  = Parallel Scavenge + Parallel Old ，表示新⽣代⽤       Parallel Scavenge 收集器，⽼年代
使⽤   Parallel Old  收集器。

因此你也可以这样回答：

我们系统的业务相对复杂，但并发量并不是特别⾼，所以我们选择了适⽤于多核处理器、能够并⾏处理垃圾回收任
务，且能提供⾼吞吐量的           Parallel GC 。

但这个说法不讨喜，你也可以回答：

我们系统采⽤的是 CMS 收集器，能够最⼤限度减少应⽤暂停时间。

⼯作中项⽬使⽤的什么垃圾回收算法？                                                                                 

我们⽣产环境中采⽤了设计⽐较优秀的 G1 垃圾收集器，G1 采⽤的是分区式标记-整理算法，将堆划分为多个区
域，按需回收，适⽤于⼤内存和多核环境，能够同时考虑吞吐量和暂停时间。

或者：

我们系统采⽤的是 CMS 收集器，CMS 采⽤的是标记-清除算法，能够并发标记和清除垃圾，减少暂停时间，适⽤
于对延迟敏感的应⽤。

再或者：

我们系统采⽤的是 Parallel 收集器，Parallel 采⽤的是年轻代使⽤复制算法，⽼年代使⽤标记-整理算法，适⽤于⾼
吞吐量要求的应⽤。

     1. Java ⾯试指南（付费）收录的华为 OD ⾯经同学 3 技术⼆⾯⾯试原题：⼯作中项⽬使⽤的什么垃圾回收
        算法

36.垃圾收集器应该如何选择？                                                                                   

如果应⽤程序只需要⼀个很⼩的内存空间（⼤约 100 MB），或者对停顿时间没有特殊的要求，可以选择 Serial 收
集器。

如果优先考虑应⽤程序的峰值性能，并且没有时间要求，或者可以接受 1 秒或更⻓的停顿时间，可以选择 Parallel 
收集器。

如果响应时间⽐吞吐量优先级⾼，或者垃圾收集暂停必须保持在⼤约 1 秒以内，可以选择 CMS/ G1 收集器。

如果响应时间是⾼优先级的，或者堆空间⽐较⼤，可以选择 ZGC 收集器。

memo：2025 年 1 ⽉ 16 ⽇修改⾄此。
四、JVM 调优                                                                                          

37.⽤过哪些性能监控的命令⾏⼯具？                                                                                

操作系统层⾯，我⽤过 top、vmstat、iostat、netstat 等命令，可以监控系统整体的资源使⽤情况，⽐如说内存、
CPU、IO 使⽤情况、⽹络使⽤情况。

JDK ⾃带的命令⾏⼯具层⾯，我⽤过 jps、jstat、jinfo、jmap、jhat、jstack、jcmd 等，可以查看 JVM 运⾏时信
息、内存使⽤情况、堆栈信息等。

你⼀般都怎么⽤jmap？                                                                                      

                                             No. 70 / 95
                                ⾯渣逆袭 JVM篇第⼆版-让天下所有的⾯渣都能逆袭

①、我⼀般会使⽤         jmap -heap <pid>  查看堆内存摘要，包括新⽣代、⽼年代、元空间等。


②、或者使⽤       jmap -histo <pid>  查看对象分布。


                                             No. 71 / 95
                                ⾯渣逆袭 JVM篇第⼆版-让天下所有的⾯渣都能逆袭


③、还有⽣成堆转储⽂件：            jmap -dump:format=b,file=<path> <pid>  。


     1. Java ⾯试指南（付费）收录的哔哩哔哩同学 1 ⼆⾯⾯试原题：你是如何使⽤jmap，你⽤过哪些命令？

38.了解哪些可视化的性能监控⼯具？                                                                                

我⾃⼰⽤过的可视化⼯具主要有：

①、JConsole：JDK ⾃带的监控⼯具，可以⽤来监视 Java 应⽤程序的运⾏状态，包括内存使⽤、线程状态、类加
载、GC 等。


                                             No. 72 / 95
                                ⾯渣逆袭 JVM篇第⼆版-让天下所有的⾯渣都能逆袭


②、VisualVM：⼀个基于 NetBeans 的可视化⼯具，在很⻓⼀段时间内，VisualVM 都是 Oracle 官⽅主推的故障
处理⼯具。集成了多个 JDK 命令⾏⼯具的功能，⾮常友好。


                                             No. 73 / 95
                                ⾯渣逆袭 JVM篇第⼆版-让天下所有的⾯渣都能逆袭

③、Java Mission Control：JMC 最初是 JRockit VM 中的诊断⼯具，但在 Oracle JDK7 Update 40 以后，就绑定到
了 HotSpot VM 中。不过后来⼜被 Oracle 开源出来作为了⼀个单独的产品。


⽤过哪些第三⽅的⼯具？                                                                                       

①、MAT：⼀个 Java 堆内存分析⼯具，主要⽤于分析和查找 Java 堆中的内存泄漏和内存消耗问题；可以从 Java 
堆转储⽂件中分析内存使⽤情况，并提供丰富的报告，如内存泄漏疑点、最⼤对象和 GC 根信息；⽀持通过图形界
⾯查询对象，以及检查对象间的引⽤关系。

②、GChisto：GC ⽇志分析⼯具，可以帮助我们优化垃圾收集⾏为和调整 GC 性能。

③、JProfiler：⼀个全功能的商业化 Java 性能分析⼯具，提供 CPU、 内存和线程的实时分析。

④、arthas：阿⾥巴巴开源的 Java 诊断⼯具，主要⽤于线上的应⽤诊断；⽀持在不停机的情况下进⾏诊断；可以
提供包括 JVM 信息查看、监控、Trace 命令、反编译等功能。

⑤、async-profiler：⼀个低开销的性能分析⼯具，⽀持⽣成⽕焰图，适⽤于复杂性能问题的分析。

     1. Java ⾯试指南（付费）收录的华为⾯经同学 9 Java 通⽤软件开发⼀⾯⾯试原题：如何查看当前 Java 程
        序⾥哪些对象正在使⽤，哪些对象已经被释放

39.JVM 的常⻅参数配置知道哪些？                                                                               

配置堆内存⼤⼩的参数有哪些？                                                                                    

     -Xms ：初始堆⼤⼩

     -Xmx ：最⼤堆⼤⼩

     -XX:NewSize=n ：设置年轻代⼤⼩

     -XX:NewRatio=n ：设置年轻代和年⽼代的⽐值。如：n 为 3 表示年轻代和年⽼代⽐值为 1：3，年轻代占总
     和的 1/4

     -XX:SurvivorRatio=n ：年轻代中 Eden 区与两个 Survivor 区的⽐值。如 n=3 表示 Eden 占 3 Survivor 占 
     2，⼀个 Survivor 区占整个年轻代的 1/5

                                             No. 74 / 95
                                ⾯渣逆袭 JVM篇第⼆版-让天下所有的⾯渣都能逆袭

配置 GC 收集器的参数有哪些？                                                                                  

     -XX:+UseSerialGC ：设置串⾏收集器

     -XX:+UseParallelGC ：设置并⾏收集器

     -XX:+UseParalledlOldGC  ：设置并⾏⽼年代收集器

     -XX:+UseConcMarkSweepGC  ：设置并发收集器

配置并⾏收集的参数有哪些？                                                                                     

     -XX:MaxGCPauseMillis=n  ：设置最⼤垃圾回收停顿时间

     -XX:GCTimeRatio=n ：设置垃圾回收时间占程序运⾏时间的⽐例

     -XX:+CMSIncrementalMode  ：设置增量模式，适合单 CPU 环境

     -XX:ParallelGCThreads=n  ：设置并⾏收集器的线程数

打印 GC 回收的过程⽇志信息的参数有哪些？                                                                            

     -XX:+PrintGC ：输出 GC ⽇志

     -XX:+PrintGCDetails ：输出 GC 详细⽇志

     -XX:+PrintGCTimeStamps  ：输出 GC 的时间戳（以基准时间的形式）

     -Xloggc:filename ：⽇志⽂件的输出路径

40.做过 JVM 调优吗？                                                                                    

做过。

JVM 调优是⼀个复杂的过程，调优的对象包括堆内存、垃圾收集器和 JVM 运⾏时参数等。


如果堆内存设置过⼩，可能会导致频繁的垃圾回收。所以在技术派实战项⽬中，启动 JVM 的时候配置了                                        -Xms  和 
 -Xmx  参数，让堆内存最⼤可⽤内存为 2G（我⽤的丐版服务器）。


                                             No. 75 / 95
                                ⾯渣逆袭 JVM篇第⼆版-让天下所有的⾯渣都能逆袭

在项⽬运⾏期间，我会使⽤ JVisualVM 定期观察和分析 GC ⽇志，如果发现频繁的 Full GC，我会特意关注⼀下⽼
年代的使⽤情况。

接着，通过分析 Heap dump 寻找内存泄漏的源头，看看是否有未关闭的资源，⻓⽣命周期的⼤对象等。

之后进⾏代码优化，⽐如说减少⼤对象的创建、优化数据结构的使⽤⽅式、减少不必要的对象持有等。

     1. Java ⾯试指南（付费）收录的华为⾯经同学 6 Java 通⽤软件开发⼀⾯⾯试原题：说说你对 JVM 调优的
        了解

41.CPU 占⽤过⾼怎么排查？                                                                                  


⾸先，使⽤ top 命令查看 CPU 占⽤情况，找到占⽤ CPU 较⾼的进程 ID。

  top


接着，使⽤ jstack 命令查看对应进程的线程堆栈信息。


                                             No. 76 / 95
                                   ⾯渣逆袭 JVM篇第⼆版-让天下所有的⾯渣都能逆袭


  jstack -l <pid> > thread-dump.txt

   上⾯       这个命令会将所有线程的堆栈信息输出到 thread-dump.txt ⽂件中。

然后再使⽤ top 命令查看进程中线程的占⽤情况，找到占⽤ CPU 较⾼的线程 ID。

  top -H -p <pid>


   注意，top 命令显示的线程 ID 是⼗进制的，⽽ jstack 输出的是⼗六进制的，所以需要将线程 ID 转换为⼗六
   进制。

  printf "%x\n" PID

接着在 jstack 的输出中搜索这个⼗六进制的线程 ID，找到对应的堆栈信息。

  "Thread-5" #21 prio=5 os_prio=0 tid=0x00007f812c018800 nid=0x1a85 runnable 
  [0x00007f811c000000]
     java.lang.Thread.State: RUNNABLE
      at com.example.MyClass.myMethod(MyClass.java:123)
      at ...


                                                  No. 77 / 95
                                ⾯渣逆袭 JVM篇第⼆版-让天下所有的⾯渣都能逆袭

最后，根据堆栈信息定位到具体的业务⽅法，查看是否有死循环、频繁的垃圾回收、资源竞争导致的上下⽂频繁切
换等问题。

     1. Java ⾯试指南（付费）收录的阿⾥⾯经同学 1 闲⻥后端⼀⾯的原题：上线的业务出了问题怎么调试，⽐
        如某个线程 cpu 占⽤率⾼，怎么看堆栈信息

     2. Java ⾯试指南（付费）收录的快⼿同学 4 ⼀⾯原题：服务器的CPU占⽤持续升⾼，有哪些排查问题的⼿
        段？排查后发现是项⽬产⽣了内存泄露，如何确定问题出在哪⾥？

42.内存飙⾼问题怎么排查？                                                                                    

内存飚⾼⼀般是因为创建了⼤量的 Java 对象导致的，如果持续飙⾼则说明垃圾回收跟不上对象创建的速度，或者
内存泄漏导致对象⽆法回收。

排查的⽅法主要分为以下⼏步：

第⼀，先观察垃圾回收的情况，可以通过                  jstat -gc PID 1000  查看 GC 次数和时间。

或者使⽤     jmap -histo PID | head -20  查看堆内存占⽤空间最⼤的前 20 个对象类型。

第⼆步，通过 jmap 命令 dump 出堆内存信息。


第三步，使⽤可视化⼯具分析 dump ⽂件，⽐如说 VisualVM，找到占⽤内存⾼的对象，再找到创建该对象的业务
代码位置，从代码和业务场景中定位具体问题。


                                             No. 78 / 95
                                ⾯渣逆袭 JVM篇第⼆版-让天下所有的⾯渣都能逆袭


     1. Java ⾯试指南（付费）收录的联想⾯经同学 7 ⾯试原题：怎么定位线上的内存问题。

43.频繁 minor gc 怎么办？                                                                               

频繁的 Minor GC 通常意味着新⽣代中的对象频繁地被垃圾回收，可能是因为新⽣代空间设置的过⼩，或者是因为
程序中存在⼤量的短⽣命周期对象（如临时变量）。

可以使⽤ GC ⽇志进⾏分析，查看 GC 的频率和耗时，找到频繁 GC 的原因。

  -XX:+PrintGCDetails -Xloggc:gc.log

或者使⽤监控⼯具查看堆内存的使⽤情况，特别是新⽣代（Eden 和 Survivor 区）的使⽤情况。

如果是因为新⽣代空间不⾜，可以通过                 -Xmn  增加新⽣代的⼤⼩，减缓新⽣代的填满速度。

  java -Xmn256m your-app.jar

如果对象需要⻓期存活，但频繁从 Survivor 区晋升到⽼年代，可以通过                         -XX:SurvivorRatio  参数调整 Eden 和 
Survivor 的⽐例。默认⽐例是 8:1，表示 8 个空间⽤于 Eden，1 个空间⽤于 Survivor 区。

  -XX:SurvivorRatio=6

调整为 6 的话，会减少 Eden 区的⼤⼩，增加 Survivor 区的⼤⼩，以确保对象在 Survivor 区中存活的时间⾜够
⻓，避免过早晋升到⽼年代。

     1. Java ⾯试指南（付费）收录的京东⾯经同学 8 ⾯试原题：young GC频繁如何排查？修改哪些参数？ 

44.频繁 Full GC 怎么办？                                                                                


                                             No. 79 / 95
                                ⾯渣逆袭 JVM篇第⼆版-让天下所有的⾯渣都能逆袭

频繁的 Full GC 通常意味着⽼年代中的对象频繁地被垃圾回收，可能是因为⽼年代空间设置的过⼩，或者是因为程
序中存在⼤量的⻓⽣命周期对象。

该怎么排查 Full GC 频繁问题？                                                                               

我⼚会通过专⻔的性能监控系统，查看 GC 的频率和堆内存的使⽤情况，然后根据监控数据分析 GC 的原因。

如果是⼩⼚，可以这么回复。

我⼀般会使⽤ JDK 的⾃带⼯具，包括 jmap、jstat 等。

  # 查看堆内存各区域的使⽤率以及GC情况
  jstat -gcutil -h20 pid 1000
  # 查看堆内存中的存活对象，并按空间排序
  jmap -histo pid | head -n20
  # dump堆内存⽂件
  jmap -dump:format=b,file=heap pid

或者使⽤⼀些可视化的⼯具，⽐如 VisualVM、JConsole 等，查看堆内存的使⽤情况。

假如是因为⼤对象直接分配到⽼年代导致的 Full GC 频繁，可以通过                       -XX:PretenureSizeThreshold   参数设置⼤
对象直接进⼊⽼年代的阈值。

或者将⼤对象拆分成⼩对象，减少⼤对象的创建。⽐如说分⻚。

假如是因为内存泄漏导致的频繁 Full GC，可以通过分析堆内存 dump ⽂件找到内存泄漏的对象，再找到内存泄漏
的代码位置。

假如是因为⻓⽣命周期的对象进⼊到了⽼年代，要及时释放资源，⽐如说 ThreadLocal、数据库连接、IO 资源
等。

假如是因为 GC 参数配置不合理导致的频繁 Full GC，可以通过调整 GC 参数来优化 GC ⾏为。或者直接更换更适合
的 GC 收集器，如 G1、ZGC 等。

     1. Java ⾯试指南（付费）收录的得物⾯经同学 8 ⼀⾯⾯试原题：Java 中 full gc 频繁，有哪些原因
五、类加载机制                                                                                           

45.     了解类的加载机制吗？（补充）                                                                            

   2024 年 03 ⽉ 29 ⽇增补

了解。

JVM 的操作对象是 Class ⽂件，JVM 把 Class ⽂件中描述类的数据结构加载到内存中，并对数据进⾏校验、解析和
初始化，最终转化成可以被 JVM 直接使⽤的类型，这个过程被称为类加载机制。

其中最重要的三个概念就是：类加载器、类加载过程和双亲委派模型。

     类加载器：负责加载类⽂件，将类⽂件加载到内存中，⽣成 Class 对象。

     类加载过程：包括加载、验证、准备、解析和初始化等步骤。

     双亲委派模型：当⼀个类加载器接收到类加载请求时，它会把请求委派给⽗——类加载器去完成，依次递
     归，直到最顶层的类加载器，如果⽗——类加载器⽆法完成加载请求，⼦类加载器才会尝试⾃⼰去加载。

                                            No. 80 / 95
                                ⾯渣逆袭 JVM篇第⼆版-让天下所有的⾯渣都能逆袭

     1. Java ⾯试指南（付费）收录的⼩⽶暑期实习同学 E ⼀⾯⾯试原题：你了解类的加载机制吗？

     2. Java ⾯试指南（付费）收录的美团⾯经同学 3 Java 后端技术⼀⾯⾯试原题：java 的类加载机制 双亲委
        派机制 这样设计的原因是什么

46.类加载器有哪些？                                                                                       

主要有四种：

①、启动类加载器，负责加载 JVM 的核⼼类库，如 rt.jar 和其他核⼼库位于                       JAVA_HOME/jre/lib ⽬录下的类。

②、扩展类加载器，负责加载             JAVA_HOME/jre/lib/ext ⽬录下，或者由系统属性           java.ext.dirs 指定位置的类
库，由    sun.misc.Launcher$ExtClassLoader  实现。

③、应⽤程序类加载器，负责加载 classpath 的类库，由                  sun.misc.Launcher$AppClassLoader 实现。

我们编写的任何类都是由应⽤程序类加载器加载的，除⾮显式使⽤⾃定义类加载器。

④、⽤户⾃定义类加载器，通常⽤于加载⽹络上的类、执⾏热部署（动态加载和替换应⽤程序的组件），或者为了
安全考虑，从不同的源加载类。

通过继承     java.lang.ClassLoader 类来实现。

47.能说⼀下类的⽣命周期吗？                                                                                   

⼀个类从被加载到虚拟机内存中开始，到从内存中卸载，整个⽣命周期需要经过七个阶段：加载 、验证、准备、
解析、初始化、使⽤和卸载。


48.     类装载的过程知道吗？                                                                                

   推荐阅读：⼀⽂彻底搞懂 Java 类加载机制

知道。

类装载过程包括三个阶段：载⼊、链接和初始化。

①、载⼊：将类的⼆进制字节码加载到内存中。


                                             No. 81 / 95
                                ⾯渣逆袭 JVM篇第⼆版-让天下所有的⾯渣都能逆袭

②、链接可以细分为三个⼩的阶段：

     验证：检查类⽂件格式是否符合 JVM 规范

     准备：为类的静态变量分配内存并设置默认值。

     解析：将符号引⽤替换为直接引⽤。

③、初始化：执⾏静态代码块和静态变量初始化。

在准备阶段，静态变量已经被赋过默认初始值了，在初始化阶段，静态变量将被赋值为代码期望赋的值。⽐如说 
 static int a = 1; ，在准备阶段，       a  的值为 0，在初始化阶段，         a  的值为 1。

换句话说，初始化阶段是在执⾏类的构造⽅法，也就是 javap 中看到的                          <clinit>() 。

载⼊过程 JVM 会做什么？                                                                                    


     1）通过⼀个类的全限定名来获取定义此类的⼆进制字节流。

     2）将这个字节流所代表的静态存储结构转化为⽅法区的运⾏时数据结构。

     3）在内存中⽣成⼀个代表这个类的               java.lang.Class  对象，作为这个类的访问⼊⼝。

     1. Java ⾯试指南（付费）收录的⼩⽶暑期实习同学 E ⼀⾯⾯试原题：你了解类的加载机制吗？

     2. Java ⾯试指南（付费）收录的美团⾯经同学 16 暑期实习⼀⾯⾯试原题：讲⼀下类加载过程，双亲委派
        模型，双亲委派的好处

     3. Java ⾯试指南（付费）收录的美团⾯经同学 18 成都到家⾯试原题：类加载过程

     4. Java ⾯试指南（付费）收录的快⼿同学 4 ⼀⾯原题：类装载的执⾏过程？双亲委派模式是什么？为什么
        使⽤这种模式？

memo：2025 年 1 ⽉ 17 ⽇修改⾄此。

                                             No. 82 / 95
                                ⾯渣逆袭 JVM篇第⼆版-让天下所有的⾯渣都能逆袭

49.     什么是双亲委派模型？                                                                                

双亲委派模型要求类加载器在加载类时，先委托⽗加载器尝试加载，只有⽗加载器⽆法加载时，⼦加载器才会加
载。


这个过程会⼀直向上递归，也就是说，从⼦加载器到⽗加载器，再到更上层的加载器，⼀直到最顶层的启动类加载
器。

启动类加载器会尝试加载这个类。如果它能够加载这个类，就直接返回；如果它不能加载这个类，就会将加载任务
返回给委托它的⼦加载器。

⼦加载器尝试加载这个类。如果⼦加载器也⽆法加载这个类，它就会继续向下传递这个加载任务，依此类推。

直到某个加载器能够加载这个类，或者所有加载器都⽆法加载这个类，最终抛出 ClassNotFoundException。

     1. Java ⾯试指南（付费）收录的⼩⽶暑期实习同学 E ⼀⾯⾯试原题：你了解类的加载机制吗？

     2. Java ⾯试指南（付费）收录的阿⾥云⾯经同学 22 ⾯经：双亲委派机制

49.为什么要⽤双亲委派模型？                                                                                   

①、避免类的重复加载：⽗加载器加载的类，⼦加载器⽆需重复加载。

②、保证核⼼类库的安全性：如              java.lang.*  只能由 Bootstrap ClassLoader 加载，防⽌被篡改。

     1. Java ⾯试指南（付费）收录的美团⾯经同学 16 暑期实习⼀⾯⾯试原题：讲⼀下类加载过程，双亲委派
        模型，双亲委派的好处

50.如何破坏双亲委派机制？                                                                                    


                                            No. 83 / 95
                                ⾯渣逆袭 JVM篇第⼆版-让天下所有的⾯渣都能逆袭

重写 ClassLoader 的   loadClass()  ⽅法。

如果不想打破双亲委派模型，就重写 ClassLoader 类中的                  findClass()  ⽅法，那些⽆法被⽗类加载器加载的类最
终会通过这个⽅法被加载。

memo：2025 年 1 ⽉ 18 ⽇修改⾄此。

51.有哪些破坏双亲委派模型的典型例⼦？                                                                              

我了解的有两种：

     第⼀种：SPI 机制加载 JDBC 驱动。

     第⼆种：热部署框架。


说说SPI 机制？                                                                                         

SPI 是 Java 的⼀种扩展机制，⽤于加载和注册第三⽅类库，常⻅于 JDBC、JNDI 等框架。

双亲委派模型会优先让⽗类加载器加载类，⽽ SPI 需要动态加载⼦类加载器中的实现。

根据双亲委派模型，         java.sql.Driver  类应该由⽗加载器加载，但⽗类加载器⽆法加载由⼦类加载器定义的驱动
类，如 MySQL 的     com.mysql.cj.jdbc.Driver  。

那么只能使⽤ SPI 机制通过         META-INF/services  ⽂件指定服务提供者的实现类。

  ClassLoader cl = Thread.currentThread().getContextClassLoader();
  Enumeration<Driver> drivers = ServiceLoader.load(Driver.class, cl).iterator();

DriverManager 使⽤了线程上下⽂类加载器来加载 SPI 的实现类，从⽽允许⼦类加载器加载具体的 JDBC 驱动。

说说热部署？                                                                                            


                                            No. 84 / 95
                                ⾯渣逆袭 JVM篇第⼆版-让天下所有的⾯渣都能逆袭

热部署是指在不重启服务器的情况下更新应⽤程序代码，需要替换旧版本的类，但旧版本的类可能由⽗加载器加
载。

如 Spring Boot 的 DevTools 通常会⾃定义类加载器，优先加载新的类版本。

memo：2025 年 1 ⽉ 19 ⽇修改⾄此。

52.Tomcat 的类加载机制了解吗？                                                                              

了解。

Tomcat 基于双亲委派模型进⾏了⼀些扩展，主要的类加载器有：

     Bootstrap ClassLoader：加载 Java 的核⼼类库；

     Catalina ClassLoader：加载 Tomcat 的核⼼类库；

     Shared ClassLoader：加载共享类库，允许多个 Web 应⽤共享某些类库；

     WebApp ClassLoader：加载 Web 应⽤程序的类库，⽀持多应⽤隔离和优先加载应⽤⾃定义的类库（破坏了
     双亲委派模型）。


 

53.你觉得应该怎么实现⼀个热部署功能？                                                                              


                                            No. 85 / 95
                                   ⾯渣逆袭 JVM篇第⼆版-让天下所有的⾯渣都能逆袭

热部署是指在不重启服务器的情况下，动态加载、更新或卸载应⽤程序的组件，⽐如类、配置⽂件等。

需要在类加载器的基础上，实现类的重新加载。

我的思路是：

第⼀步，使⽤⽂件监控机制，如 Java NIO 的 WatchService 来监控类⽂件或配置⽂件的变化。当监控到⽂件变更
时，触发热部署流程。

  class FileWatcher {

      public static void watchDirectoryPath(Path path) {
          // 检查路径是否是有效⽬录
          if (!isDirectory(path)) {
              System.err.println("Provided path is not a directory: " + path);
              return;
          }

          System.out.println("Starting to watch path: " + path);

          // 获取⽂件系统的 WatchService
          try (WatchService watchService = path.getFileSystem().newWatchService()) {
              // 注册⽬录监听服务，监听创建、修改和删除事件
              path.register(watchService, ENTRY_CREATE, ENTRY_MODIFY, ENTRY_DELETE);

              while (true) {
                  WatchKey key;
                  try {
                      // 阻塞直到有事件发⽣
                      key = watchService.take();
                  } catch (InterruptedException e) {
                      System.out.println("WatchService interrupted, stopping directory 
  watch.");
                      Thread.currentThread().interrupt();
                      break;
                  }

                  // 处理事件
                  for (WatchEvent<?> event : key.pollEvents()) {
                      processEvent(event);
                  }

                  // 重置 key，如果失败则退出
                  if (!key.reset()) {
                      System.out.println("WatchKey no longer valid. Exiting watch loop.");
                      break;
                  }
              }
          } catch (IOException e) {
              System.err.println("An error occurred while setting up the WatchService: " + 
  e.getMessage());
              e.printStackTrace();


                                                  No. 86 / 95
                                   ⾯渣逆袭 JVM篇第⼆版-让天下所有的⾯渣都能逆袭

          }
      }

      private static boolean isDirectory(Path path) {
          return Files.isDirectory(path, LinkOption.NOFOLLOW_LINKS);
      }

      private static void processEvent(WatchEvent<?> event) {
          WatchEvent.Kind<?> kind = event.kind();

          // 处理事件类型
          if (kind == OVERFLOW) {
              System.out.println("Event overflow occurred. Some events might have been 
  lost.");
              return;
          }

          @SuppressWarnings("unchecked")
          Path fileName = ((WatchEvent<Path>) event).context();
          System.out.println("Event: " + kind.name() + ", File affected: " + fileName);
      }

      public static void main(String[] args) {
          // 设置监控路径为当前⽬录
          Path pathToWatch = Paths.get(".");
          watchDirectoryPath(pathToWatch);
      }
  }

第⼆步，创建⼀个⾃定义类加载器，继承                      java.lang.ClassLoader    ，并重写     findClass()  ⽅法，⽤来加载新的类
⽂件。

  class HotSwapClassLoader extends ClassLoader {
      public HotSwapClassLoader() {
          super(ClassLoader.getSystemClassLoader());
      }

      @Override
      protected Class<?> findClass(String name) throws ClassNotFoundException {
          // 加载指定路径下的类⽂件字节码
          byte[] classBytes = loadClassData(name);
          if (classBytes == null) {
              throw new ClassNotFoundException(name);
          }
          // 调⽤defineClass将字节码转换为Class对象
          return defineClass(name, classBytes, 0, classBytes.length);
      }

      private byte[] loadClassData(String name) {
          // 实现从⽂件系统或其他来源加载类⽂件的字节码
          // ...


                                                  No. 87 / 95
                                ⾯渣逆袭 JVM篇第⼆版-让天下所有的⾯渣都能逆袭

          return null;
      }
  }

友情提示：Intellij IDEA 提供了热部署功能，当我们修改了代码后，IDEA 会⾃动保存并编译，如果是 Web 项⽬，
还可以在 Chrome 浏览器中装⼀个 LiveReload 插件，⼀旦编译完成，⻚⾯就会⾃动刷新看到最新的效果。对于测
试或者调试来说，⾮常⽅便。

     1. Java ⾯试指南（付费）收录的⼩⽶暑期实习同学 E ⼀⾯⾯试原题：那你知道类的热更新的？

54.说说解释执⾏和编译执⾏的区别（补充）                                                                             

   2024 年 03 ⽉ 08 ⽇增补

先说解释和编译的区别：

     解释：将源代码逐⾏转换为机器码。

     编译：将源代码⼀次性转换为机器码。

⼀个是逐⾏，⼀个是⼀次性，再来说说解释执⾏和编译执⾏的区别：

     解释执⾏：程序运⾏时，将源代码逐⾏转换为机器码，然后执⾏。

     编译执⾏：程序运⾏前，将源代码⼀次性转换为机器码，然后执⾏。

Java ⼀般被称为“解释型语⾔”，因为 Java 代码在执⾏前，需要先将源代码编译成字节码，然后在运⾏时，再由 
JVM 的解释器“逐⾏”将字节码转换为机器码，然后执⾏。

这也是 Java 被诟病“慢”的主要原因。

但 JIT 的出现打破了这种刻板印象，JVM 会将热点代码（即运⾏频率⾼的代码）编译后放⼊ CodeCache，当下次执
⾏再遇到这段代码时，会从 CodeCache 中直接读取机器码，然后执⾏。

因此，Java 的执⾏效率得到了⼤幅提升。

